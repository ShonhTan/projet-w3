// Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  challenge: (where?: ChallengeWhereInput) => Promise<boolean>;
  company: (where?: CompanyWhereInput) => Promise<boolean>;
  photo: (where?: PhotoWhereInput) => Promise<boolean>;
  place: (where?: PlaceWhereInput) => Promise<boolean>;
  quiz: (where?: QuizWhereInput) => Promise<boolean>;
  tag: (where?: TagWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  challenge: (where: ChallengeWhereUniqueInput) => ChallengeNullablePromise;
  challenges: (args?: {
    where?: ChallengeWhereInput;
    orderBy?: ChallengeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Challenge>;
  challengesConnection: (args?: {
    where?: ChallengeWhereInput;
    orderBy?: ChallengeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ChallengeConnectionPromise;
  company: (where: CompanyWhereUniqueInput) => CompanyNullablePromise;
  companies: (args?: {
    where?: CompanyWhereInput;
    orderBy?: CompanyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Company>;
  companiesConnection: (args?: {
    where?: CompanyWhereInput;
    orderBy?: CompanyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CompanyConnectionPromise;
  photo: (where: PhotoWhereUniqueInput) => PhotoNullablePromise;
  photos: (args?: {
    where?: PhotoWhereInput;
    orderBy?: PhotoOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Photo>;
  photosConnection: (args?: {
    where?: PhotoWhereInput;
    orderBy?: PhotoOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PhotoConnectionPromise;
  place: (where: PlaceWhereUniqueInput) => PlaceNullablePromise;
  places: (args?: {
    where?: PlaceWhereInput;
    orderBy?: PlaceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Place>;
  placesConnection: (args?: {
    where?: PlaceWhereInput;
    orderBy?: PlaceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PlaceConnectionPromise;
  quiz: (where: QuizWhereUniqueInput) => QuizNullablePromise;
  quizzes: (args?: {
    where?: QuizWhereInput;
    orderBy?: QuizOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Quiz>;
  quizzesConnection: (args?: {
    where?: QuizWhereInput;
    orderBy?: QuizOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => QuizConnectionPromise;
  tag: (where: TagWhereUniqueInput) => TagNullablePromise;
  tags: (args?: {
    where?: TagWhereInput;
    orderBy?: TagOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Tag>;
  tagsConnection: (args?: {
    where?: TagWhereInput;
    orderBy?: TagOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => TagConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserNullablePromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createChallenge: (data: ChallengeCreateInput) => ChallengePromise;
  updateChallenge: (args: {
    data: ChallengeUpdateInput;
    where: ChallengeWhereUniqueInput;
  }) => ChallengePromise;
  updateManyChallenges: (args: {
    data: ChallengeUpdateManyMutationInput;
    where?: ChallengeWhereInput;
  }) => BatchPayloadPromise;
  upsertChallenge: (args: {
    where: ChallengeWhereUniqueInput;
    create: ChallengeCreateInput;
    update: ChallengeUpdateInput;
  }) => ChallengePromise;
  deleteChallenge: (where: ChallengeWhereUniqueInput) => ChallengePromise;
  deleteManyChallenges: (where?: ChallengeWhereInput) => BatchPayloadPromise;
  createCompany: (data: CompanyCreateInput) => CompanyPromise;
  updateCompany: (args: {
    data: CompanyUpdateInput;
    where: CompanyWhereUniqueInput;
  }) => CompanyPromise;
  updateManyCompanies: (args: {
    data: CompanyUpdateManyMutationInput;
    where?: CompanyWhereInput;
  }) => BatchPayloadPromise;
  upsertCompany: (args: {
    where: CompanyWhereUniqueInput;
    create: CompanyCreateInput;
    update: CompanyUpdateInput;
  }) => CompanyPromise;
  deleteCompany: (where: CompanyWhereUniqueInput) => CompanyPromise;
  deleteManyCompanies: (where?: CompanyWhereInput) => BatchPayloadPromise;
  createPhoto: (data: PhotoCreateInput) => PhotoPromise;
  updatePhoto: (args: {
    data: PhotoUpdateInput;
    where: PhotoWhereUniqueInput;
  }) => PhotoPromise;
  updateManyPhotos: (args: {
    data: PhotoUpdateManyMutationInput;
    where?: PhotoWhereInput;
  }) => BatchPayloadPromise;
  upsertPhoto: (args: {
    where: PhotoWhereUniqueInput;
    create: PhotoCreateInput;
    update: PhotoUpdateInput;
  }) => PhotoPromise;
  deletePhoto: (where: PhotoWhereUniqueInput) => PhotoPromise;
  deleteManyPhotos: (where?: PhotoWhereInput) => BatchPayloadPromise;
  createPlace: (data: PlaceCreateInput) => PlacePromise;
  updatePlace: (args: {
    data: PlaceUpdateInput;
    where: PlaceWhereUniqueInput;
  }) => PlacePromise;
  updateManyPlaces: (args: {
    data: PlaceUpdateManyMutationInput;
    where?: PlaceWhereInput;
  }) => BatchPayloadPromise;
  upsertPlace: (args: {
    where: PlaceWhereUniqueInput;
    create: PlaceCreateInput;
    update: PlaceUpdateInput;
  }) => PlacePromise;
  deletePlace: (where: PlaceWhereUniqueInput) => PlacePromise;
  deleteManyPlaces: (where?: PlaceWhereInput) => BatchPayloadPromise;
  createQuiz: (data: QuizCreateInput) => QuizPromise;
  updateQuiz: (args: {
    data: QuizUpdateInput;
    where: QuizWhereUniqueInput;
  }) => QuizPromise;
  updateManyQuizzes: (args: {
    data: QuizUpdateManyMutationInput;
    where?: QuizWhereInput;
  }) => BatchPayloadPromise;
  upsertQuiz: (args: {
    where: QuizWhereUniqueInput;
    create: QuizCreateInput;
    update: QuizUpdateInput;
  }) => QuizPromise;
  deleteQuiz: (where: QuizWhereUniqueInput) => QuizPromise;
  deleteManyQuizzes: (where?: QuizWhereInput) => BatchPayloadPromise;
  createTag: (data: TagCreateInput) => TagPromise;
  updateTag: (args: {
    data: TagUpdateInput;
    where: TagWhereUniqueInput;
  }) => TagPromise;
  updateManyTags: (args: {
    data: TagUpdateManyMutationInput;
    where?: TagWhereInput;
  }) => BatchPayloadPromise;
  upsertTag: (args: {
    where: TagWhereUniqueInput;
    create: TagCreateInput;
    update: TagUpdateInput;
  }) => TagPromise;
  deleteTag: (where: TagWhereUniqueInput) => TagPromise;
  deleteManyTags: (where?: TagWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  challenge: (
    where?: ChallengeSubscriptionWhereInput
  ) => ChallengeSubscriptionPayloadSubscription;
  company: (
    where?: CompanySubscriptionWhereInput
  ) => CompanySubscriptionPayloadSubscription;
  photo: (
    where?: PhotoSubscriptionWhereInput
  ) => PhotoSubscriptionPayloadSubscription;
  place: (
    where?: PlaceSubscriptionWhereInput
  ) => PlaceSubscriptionPayloadSubscription;
  quiz: (
    where?: QuizSubscriptionWhereInput
  ) => QuizSubscriptionPayloadSubscription;
  tag: (
    where?: TagSubscriptionWhereInput
  ) => TagSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type CompanyType = "COMPANY" | "SCHOOL" | "PLACE" | "COWORKING";

export type Role = "SUPER_ADMIN" | "ADMIN" | "MODERATOR" | "USER" | "PLACE";

export type CompanyOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "type_ASC"
  | "type_DESC"
  | "stripeCustomerId_ASC"
  | "stripeCustomerId_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "firstName_ASC"
  | "firstName_DESC"
  | "lastName_ASC"
  | "lastName_DESC"
  | "email_ASC"
  | "email_DESC"
  | "phone_ASC"
  | "phone_DESC"
  | "password_ASC"
  | "password_DESC"
  | "role_ASC"
  | "role_DESC"
  | "isRepresentative_ASC"
  | "isRepresentative_DESC"
  | "points_ASC"
  | "points_DESC";

export type ChallengeOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "description_ASC"
  | "description_DESC"
  | "value_ASC"
  | "value_DESC";

export type QuizOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "question_ASC"
  | "question_DESC"
  | "answer_ASC"
  | "answer_DESC"
  | "value_ASC"
  | "value_DESC";

export type PhotoOrderByInput = "id_ASC" | "id_DESC" | "url_ASC" | "url_DESC";

export type Category = "FOOD" | "SHOP" | "ACTIVITY";

export type Day =
  | "MONDAY"
  | "TUESDAY"
  | "WEDNESDAY"
  | "THURSDAY"
  | "FRIDAY"
  | "SATURDAY"
  | "SUNDAY";

export type TagOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "label_ASC"
  | "label_DESC"
  | "root_ASC"
  | "root_DESC"
  | "leaf_ASC"
  | "leaf_DESC"
  | "category_ASC"
  | "category_DESC";

export type PlaceOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "category_ASC"
  | "category_DESC"
  | "headline_ASC"
  | "headline_DESC"
  | "description_ASC"
  | "description_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type ChallengeWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface CompanyWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  type?: Maybe<CompanyType>;
  type_not?: Maybe<CompanyType>;
  type_in?: Maybe<CompanyType[] | CompanyType>;
  type_not_in?: Maybe<CompanyType[] | CompanyType>;
  address?: Maybe<AddressWhereInput>;
  users_some?: Maybe<UserWhereInput>;
  stripeCustomerId?: Maybe<String>;
  stripeCustomerId_not?: Maybe<String>;
  stripeCustomerId_in?: Maybe<String[] | String>;
  stripeCustomerId_not_in?: Maybe<String[] | String>;
  stripeCustomerId_lt?: Maybe<String>;
  stripeCustomerId_lte?: Maybe<String>;
  stripeCustomerId_gt?: Maybe<String>;
  stripeCustomerId_gte?: Maybe<String>;
  stripeCustomerId_contains?: Maybe<String>;
  stripeCustomerId_not_contains?: Maybe<String>;
  stripeCustomerId_starts_with?: Maybe<String>;
  stripeCustomerId_not_starts_with?: Maybe<String>;
  stripeCustomerId_ends_with?: Maybe<String>;
  stripeCustomerId_not_ends_with?: Maybe<String>;
  challenges_some?: Maybe<ChallengeWhereInput>;
  quizzes_some?: Maybe<QuizWhereInput>;
  AND?: Maybe<CompanyWhereInput[] | CompanyWhereInput>;
}

export interface AddressWhereInput {
  street?: Maybe<String>;
  street_not?: Maybe<String>;
  street_in?: Maybe<String[] | String>;
  street_not_in?: Maybe<String[] | String>;
  street_lt?: Maybe<String>;
  street_lte?: Maybe<String>;
  street_gt?: Maybe<String>;
  street_gte?: Maybe<String>;
  street_contains?: Maybe<String>;
  street_not_contains?: Maybe<String>;
  street_starts_with?: Maybe<String>;
  street_not_starts_with?: Maybe<String>;
  street_ends_with?: Maybe<String>;
  street_not_ends_with?: Maybe<String>;
  zipCode?: Maybe<String>;
  zipCode_not?: Maybe<String>;
  zipCode_in?: Maybe<String[] | String>;
  zipCode_not_in?: Maybe<String[] | String>;
  zipCode_lt?: Maybe<String>;
  zipCode_lte?: Maybe<String>;
  zipCode_gt?: Maybe<String>;
  zipCode_gte?: Maybe<String>;
  zipCode_contains?: Maybe<String>;
  zipCode_not_contains?: Maybe<String>;
  zipCode_starts_with?: Maybe<String>;
  zipCode_not_starts_with?: Maybe<String>;
  zipCode_ends_with?: Maybe<String>;
  zipCode_not_ends_with?: Maybe<String>;
  city?: Maybe<String>;
  city_not?: Maybe<String>;
  city_in?: Maybe<String[] | String>;
  city_not_in?: Maybe<String[] | String>;
  city_lt?: Maybe<String>;
  city_lte?: Maybe<String>;
  city_gt?: Maybe<String>;
  city_gte?: Maybe<String>;
  city_contains?: Maybe<String>;
  city_not_contains?: Maybe<String>;
  city_starts_with?: Maybe<String>;
  city_not_starts_with?: Maybe<String>;
  city_ends_with?: Maybe<String>;
  city_not_ends_with?: Maybe<String>;
  AND?: Maybe<AddressWhereInput[] | AddressWhereInput>;
}

export interface UserWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  firstName?: Maybe<String>;
  firstName_not?: Maybe<String>;
  firstName_in?: Maybe<String[] | String>;
  firstName_not_in?: Maybe<String[] | String>;
  firstName_lt?: Maybe<String>;
  firstName_lte?: Maybe<String>;
  firstName_gt?: Maybe<String>;
  firstName_gte?: Maybe<String>;
  firstName_contains?: Maybe<String>;
  firstName_not_contains?: Maybe<String>;
  firstName_starts_with?: Maybe<String>;
  firstName_not_starts_with?: Maybe<String>;
  firstName_ends_with?: Maybe<String>;
  firstName_not_ends_with?: Maybe<String>;
  lastName?: Maybe<String>;
  lastName_not?: Maybe<String>;
  lastName_in?: Maybe<String[] | String>;
  lastName_not_in?: Maybe<String[] | String>;
  lastName_lt?: Maybe<String>;
  lastName_lte?: Maybe<String>;
  lastName_gt?: Maybe<String>;
  lastName_gte?: Maybe<String>;
  lastName_contains?: Maybe<String>;
  lastName_not_contains?: Maybe<String>;
  lastName_starts_with?: Maybe<String>;
  lastName_not_starts_with?: Maybe<String>;
  lastName_ends_with?: Maybe<String>;
  lastName_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  phone?: Maybe<String>;
  phone_not?: Maybe<String>;
  phone_in?: Maybe<String[] | String>;
  phone_not_in?: Maybe<String[] | String>;
  phone_lt?: Maybe<String>;
  phone_lte?: Maybe<String>;
  phone_gt?: Maybe<String>;
  phone_gte?: Maybe<String>;
  phone_contains?: Maybe<String>;
  phone_not_contains?: Maybe<String>;
  phone_starts_with?: Maybe<String>;
  phone_not_starts_with?: Maybe<String>;
  phone_ends_with?: Maybe<String>;
  phone_not_ends_with?: Maybe<String>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  role?: Maybe<Role>;
  role_not?: Maybe<Role>;
  role_in?: Maybe<Role[] | Role>;
  role_not_in?: Maybe<Role[] | Role>;
  isRepresentative?: Maybe<Boolean>;
  isRepresentative_not?: Maybe<Boolean>;
  company?: Maybe<CompanyWhereInput>;
  points?: Maybe<Int>;
  points_not?: Maybe<Int>;
  points_in?: Maybe<Int[] | Int>;
  points_not_in?: Maybe<Int[] | Int>;
  points_lt?: Maybe<Int>;
  points_lte?: Maybe<Int>;
  points_gt?: Maybe<Int>;
  points_gte?: Maybe<Int>;
  validatedChallenges_some?: Maybe<ChallengeWhereInput>;
  validatedQuizzes_some?: Maybe<QuizWhereInput>;
  AND?: Maybe<UserWhereInput[] | UserWhereInput>;
}

export interface ChallengeWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  value?: Maybe<Int>;
  value_not?: Maybe<Int>;
  value_in?: Maybe<Int[] | Int>;
  value_not_in?: Maybe<Int[] | Int>;
  value_lt?: Maybe<Int>;
  value_lte?: Maybe<Int>;
  value_gt?: Maybe<Int>;
  value_gte?: Maybe<Int>;
  companies_some?: Maybe<CompanyWhereInput>;
  AND?: Maybe<ChallengeWhereInput[] | ChallengeWhereInput>;
}

export interface QuizWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  question?: Maybe<String>;
  question_not?: Maybe<String>;
  question_in?: Maybe<String[] | String>;
  question_not_in?: Maybe<String[] | String>;
  question_lt?: Maybe<String>;
  question_lte?: Maybe<String>;
  question_gt?: Maybe<String>;
  question_gte?: Maybe<String>;
  question_contains?: Maybe<String>;
  question_not_contains?: Maybe<String>;
  question_starts_with?: Maybe<String>;
  question_not_starts_with?: Maybe<String>;
  question_ends_with?: Maybe<String>;
  question_not_ends_with?: Maybe<String>;
  answer?: Maybe<String>;
  answer_not?: Maybe<String>;
  answer_in?: Maybe<String[] | String>;
  answer_not_in?: Maybe<String[] | String>;
  answer_lt?: Maybe<String>;
  answer_lte?: Maybe<String>;
  answer_gt?: Maybe<String>;
  answer_gte?: Maybe<String>;
  answer_contains?: Maybe<String>;
  answer_not_contains?: Maybe<String>;
  answer_starts_with?: Maybe<String>;
  answer_not_starts_with?: Maybe<String>;
  answer_ends_with?: Maybe<String>;
  answer_not_ends_with?: Maybe<String>;
  value?: Maybe<Int>;
  value_not?: Maybe<Int>;
  value_in?: Maybe<Int[] | Int>;
  value_not_in?: Maybe<Int[] | Int>;
  value_lt?: Maybe<Int>;
  value_lte?: Maybe<Int>;
  value_gt?: Maybe<Int>;
  value_gte?: Maybe<Int>;
  companies_some?: Maybe<CompanyWhereInput>;
  AND?: Maybe<QuizWhereInput[] | QuizWhereInput>;
}

export type CompanyWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type PhotoWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  url?: Maybe<String>;
}>;

export interface PhotoWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  url?: Maybe<String>;
  url_not?: Maybe<String>;
  url_in?: Maybe<String[] | String>;
  url_not_in?: Maybe<String[] | String>;
  url_lt?: Maybe<String>;
  url_lte?: Maybe<String>;
  url_gt?: Maybe<String>;
  url_gte?: Maybe<String>;
  url_contains?: Maybe<String>;
  url_not_contains?: Maybe<String>;
  url_starts_with?: Maybe<String>;
  url_not_starts_with?: Maybe<String>;
  url_ends_with?: Maybe<String>;
  url_not_ends_with?: Maybe<String>;
  AND?: Maybe<PhotoWhereInput[] | PhotoWhereInput>;
}

export type PlaceWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  name?: Maybe<String>;
}>;

export interface TagWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  label?: Maybe<String>;
  label_not?: Maybe<String>;
  label_in?: Maybe<String[] | String>;
  label_not_in?: Maybe<String[] | String>;
  label_lt?: Maybe<String>;
  label_lte?: Maybe<String>;
  label_gt?: Maybe<String>;
  label_gte?: Maybe<String>;
  label_contains?: Maybe<String>;
  label_not_contains?: Maybe<String>;
  label_starts_with?: Maybe<String>;
  label_not_starts_with?: Maybe<String>;
  label_ends_with?: Maybe<String>;
  label_not_ends_with?: Maybe<String>;
  children_some?: Maybe<TagWhereInput>;
  root?: Maybe<Boolean>;
  root_not?: Maybe<Boolean>;
  leaf?: Maybe<Boolean>;
  leaf_not?: Maybe<Boolean>;
  category?: Maybe<Category>;
  category_not?: Maybe<Category>;
  category_in?: Maybe<Category[] | Category>;
  category_not_in?: Maybe<Category[] | Category>;
  AND?: Maybe<TagWhereInput[] | TagWhereInput>;
}

export interface PlaceWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  category?: Maybe<Category>;
  category_not?: Maybe<Category>;
  category_in?: Maybe<Category[] | Category>;
  category_not_in?: Maybe<Category[] | Category>;
  address?: Maybe<AddressWhereInput>;
  user?: Maybe<UserWhereInput>;
  social?: Maybe<SocialWhereInput>;
  headline?: Maybe<String>;
  headline_not?: Maybe<String>;
  headline_in?: Maybe<String[] | String>;
  headline_not_in?: Maybe<String[] | String>;
  headline_lt?: Maybe<String>;
  headline_lte?: Maybe<String>;
  headline_gt?: Maybe<String>;
  headline_gte?: Maybe<String>;
  headline_contains?: Maybe<String>;
  headline_not_contains?: Maybe<String>;
  headline_starts_with?: Maybe<String>;
  headline_not_starts_with?: Maybe<String>;
  headline_ends_with?: Maybe<String>;
  headline_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  hours_some?: Maybe<HourWhereInput>;
  hours_every?: Maybe<HourRestrictedWhereInput>;
  hours_none?: Maybe<HourRestrictedWhereInput>;
  tags_some?: Maybe<TagWhereInput>;
  photos_some?: Maybe<PhotoWhereInput>;
  AND?: Maybe<PlaceWhereInput[] | PlaceWhereInput>;
}

export interface SocialWhereInput {
  website?: Maybe<String>;
  website_not?: Maybe<String>;
  website_in?: Maybe<String[] | String>;
  website_not_in?: Maybe<String[] | String>;
  website_lt?: Maybe<String>;
  website_lte?: Maybe<String>;
  website_gt?: Maybe<String>;
  website_gte?: Maybe<String>;
  website_contains?: Maybe<String>;
  website_not_contains?: Maybe<String>;
  website_starts_with?: Maybe<String>;
  website_not_starts_with?: Maybe<String>;
  website_ends_with?: Maybe<String>;
  website_not_ends_with?: Maybe<String>;
  facebook?: Maybe<String>;
  facebook_not?: Maybe<String>;
  facebook_in?: Maybe<String[] | String>;
  facebook_not_in?: Maybe<String[] | String>;
  facebook_lt?: Maybe<String>;
  facebook_lte?: Maybe<String>;
  facebook_gt?: Maybe<String>;
  facebook_gte?: Maybe<String>;
  facebook_contains?: Maybe<String>;
  facebook_not_contains?: Maybe<String>;
  facebook_starts_with?: Maybe<String>;
  facebook_not_starts_with?: Maybe<String>;
  facebook_ends_with?: Maybe<String>;
  facebook_not_ends_with?: Maybe<String>;
  instagram?: Maybe<String>;
  instagram_not?: Maybe<String>;
  instagram_in?: Maybe<String[] | String>;
  instagram_not_in?: Maybe<String[] | String>;
  instagram_lt?: Maybe<String>;
  instagram_lte?: Maybe<String>;
  instagram_gt?: Maybe<String>;
  instagram_gte?: Maybe<String>;
  instagram_contains?: Maybe<String>;
  instagram_not_contains?: Maybe<String>;
  instagram_starts_with?: Maybe<String>;
  instagram_not_starts_with?: Maybe<String>;
  instagram_ends_with?: Maybe<String>;
  instagram_not_ends_with?: Maybe<String>;
  AND?: Maybe<SocialWhereInput[] | SocialWhereInput>;
}

export interface HourWhereInput {
  day?: Maybe<Day>;
  day_not?: Maybe<Day>;
  day_in?: Maybe<Day[] | Day>;
  day_not_in?: Maybe<Day[] | Day>;
  start?: Maybe<String>;
  start_not?: Maybe<String>;
  start_in?: Maybe<String[] | String>;
  start_not_in?: Maybe<String[] | String>;
  start_lt?: Maybe<String>;
  start_lte?: Maybe<String>;
  start_gt?: Maybe<String>;
  start_gte?: Maybe<String>;
  start_contains?: Maybe<String>;
  start_not_contains?: Maybe<String>;
  start_starts_with?: Maybe<String>;
  start_not_starts_with?: Maybe<String>;
  start_ends_with?: Maybe<String>;
  start_not_ends_with?: Maybe<String>;
  end?: Maybe<String>;
  end_not?: Maybe<String>;
  end_in?: Maybe<String[] | String>;
  end_not_in?: Maybe<String[] | String>;
  end_lt?: Maybe<String>;
  end_lte?: Maybe<String>;
  end_gt?: Maybe<String>;
  end_gte?: Maybe<String>;
  end_contains?: Maybe<String>;
  end_not_contains?: Maybe<String>;
  end_starts_with?: Maybe<String>;
  end_not_starts_with?: Maybe<String>;
  end_ends_with?: Maybe<String>;
  end_not_ends_with?: Maybe<String>;
  AND?: Maybe<HourWhereInput[] | HourWhereInput>;
}

export interface HourRestrictedWhereInput {
  day?: Maybe<Day>;
  day_not?: Maybe<Day>;
  day_in?: Maybe<Day[] | Day>;
  day_not_in?: Maybe<Day[] | Day>;
  start?: Maybe<String>;
  start_not?: Maybe<String>;
  start_in?: Maybe<String[] | String>;
  start_not_in?: Maybe<String[] | String>;
  start_lt?: Maybe<String>;
  start_lte?: Maybe<String>;
  start_gt?: Maybe<String>;
  start_gte?: Maybe<String>;
  start_contains?: Maybe<String>;
  start_not_contains?: Maybe<String>;
  start_starts_with?: Maybe<String>;
  start_not_starts_with?: Maybe<String>;
  start_ends_with?: Maybe<String>;
  start_not_ends_with?: Maybe<String>;
  end?: Maybe<String>;
  end_not?: Maybe<String>;
  end_in?: Maybe<String[] | String>;
  end_not_in?: Maybe<String[] | String>;
  end_lt?: Maybe<String>;
  end_lte?: Maybe<String>;
  end_gt?: Maybe<String>;
  end_gte?: Maybe<String>;
  end_contains?: Maybe<String>;
  end_not_contains?: Maybe<String>;
  end_starts_with?: Maybe<String>;
  end_not_starts_with?: Maybe<String>;
  end_ends_with?: Maybe<String>;
  end_not_ends_with?: Maybe<String>;
  AND?: Maybe<HourRestrictedWhereInput[] | HourRestrictedWhereInput>;
}

export type QuizWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type TagWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type UserWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  email?: Maybe<String>;
}>;

export interface ChallengeCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  description: String;
  value: Int;
  companies?: Maybe<CompanyCreateManyWithoutChallengesInput>;
}

export interface CompanyCreateManyWithoutChallengesInput {
  create?: Maybe<
    CompanyCreateWithoutChallengesInput[] | CompanyCreateWithoutChallengesInput
  >;
  connect?: Maybe<CompanyWhereUniqueInput[] | CompanyWhereUniqueInput>;
}

export interface CompanyCreateWithoutChallengesInput {
  id?: Maybe<ID_Input>;
  name?: Maybe<String>;
  type?: Maybe<CompanyType>;
  address?: Maybe<AddressCreateOneInput>;
  users?: Maybe<UserCreateManyWithoutCompanyInput>;
  emailDomains?: Maybe<CompanyCreateemailDomainsInput>;
  stripeCustomerId?: Maybe<String>;
  quizzes?: Maybe<QuizCreateManyWithoutCompaniesInput>;
}

export interface AddressCreateOneInput {
  create?: Maybe<AddressCreateInput>;
}

export interface AddressCreateInput {
  street?: Maybe<String>;
  zipCode?: Maybe<String>;
  city?: Maybe<String>;
}

export interface UserCreateManyWithoutCompanyInput {
  create?: Maybe<
    UserCreateWithoutCompanyInput[] | UserCreateWithoutCompanyInput
  >;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
}

export interface UserCreateWithoutCompanyInput {
  id?: Maybe<ID_Input>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  email?: Maybe<String>;
  phone?: Maybe<String>;
  password?: Maybe<String>;
  role?: Maybe<Role>;
  isRepresentative?: Maybe<Boolean>;
  points?: Maybe<Int>;
  validatedChallenges?: Maybe<ChallengeCreateManyInput>;
  validatedQuizzes?: Maybe<QuizCreateManyInput>;
}

export interface ChallengeCreateManyInput {
  create?: Maybe<ChallengeCreateInput[] | ChallengeCreateInput>;
  connect?: Maybe<ChallengeWhereUniqueInput[] | ChallengeWhereUniqueInput>;
}

export interface QuizCreateManyInput {
  create?: Maybe<QuizCreateInput[] | QuizCreateInput>;
  connect?: Maybe<QuizWhereUniqueInput[] | QuizWhereUniqueInput>;
}

export interface QuizCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  question: String;
  choices?: Maybe<QuizCreatechoicesInput>;
  answer: String;
  value: Int;
  companies?: Maybe<CompanyCreateManyWithoutQuizzesInput>;
}

export interface QuizCreatechoicesInput {
  set?: Maybe<String[] | String>;
}

export interface CompanyCreateManyWithoutQuizzesInput {
  create?: Maybe<
    CompanyCreateWithoutQuizzesInput[] | CompanyCreateWithoutQuizzesInput
  >;
  connect?: Maybe<CompanyWhereUniqueInput[] | CompanyWhereUniqueInput>;
}

export interface CompanyCreateWithoutQuizzesInput {
  id?: Maybe<ID_Input>;
  name?: Maybe<String>;
  type?: Maybe<CompanyType>;
  address?: Maybe<AddressCreateOneInput>;
  users?: Maybe<UserCreateManyWithoutCompanyInput>;
  emailDomains?: Maybe<CompanyCreateemailDomainsInput>;
  stripeCustomerId?: Maybe<String>;
  challenges?: Maybe<ChallengeCreateManyWithoutCompaniesInput>;
}

export interface CompanyCreateemailDomainsInput {
  set?: Maybe<String[] | String>;
}

export interface ChallengeCreateManyWithoutCompaniesInput {
  create?: Maybe<
    | ChallengeCreateWithoutCompaniesInput[]
    | ChallengeCreateWithoutCompaniesInput
  >;
  connect?: Maybe<ChallengeWhereUniqueInput[] | ChallengeWhereUniqueInput>;
}

export interface ChallengeCreateWithoutCompaniesInput {
  id?: Maybe<ID_Input>;
  name: String;
  description: String;
  value: Int;
}

export interface QuizCreateManyWithoutCompaniesInput {
  create?: Maybe<
    QuizCreateWithoutCompaniesInput[] | QuizCreateWithoutCompaniesInput
  >;
  connect?: Maybe<QuizWhereUniqueInput[] | QuizWhereUniqueInput>;
}

export interface QuizCreateWithoutCompaniesInput {
  id?: Maybe<ID_Input>;
  name: String;
  question: String;
  choices?: Maybe<QuizCreatechoicesInput>;
  answer: String;
  value: Int;
}

export interface ChallengeUpdateInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  value?: Maybe<Int>;
  companies?: Maybe<CompanyUpdateManyWithoutChallengesInput>;
}

export interface CompanyUpdateManyWithoutChallengesInput {
  create?: Maybe<
    CompanyCreateWithoutChallengesInput[] | CompanyCreateWithoutChallengesInput
  >;
  delete?: Maybe<CompanyWhereUniqueInput[] | CompanyWhereUniqueInput>;
  connect?: Maybe<CompanyWhereUniqueInput[] | CompanyWhereUniqueInput>;
  set?: Maybe<CompanyWhereUniqueInput[] | CompanyWhereUniqueInput>;
  disconnect?: Maybe<CompanyWhereUniqueInput[] | CompanyWhereUniqueInput>;
  update?: Maybe<
    | CompanyUpdateWithWhereUniqueWithoutChallengesInput[]
    | CompanyUpdateWithWhereUniqueWithoutChallengesInput
  >;
  upsert?: Maybe<
    | CompanyUpsertWithWhereUniqueWithoutChallengesInput[]
    | CompanyUpsertWithWhereUniqueWithoutChallengesInput
  >;
  deleteMany?: Maybe<CompanyScalarWhereInput[] | CompanyScalarWhereInput>;
  updateMany?: Maybe<
    | CompanyUpdateManyWithWhereNestedInput[]
    | CompanyUpdateManyWithWhereNestedInput
  >;
}

export interface CompanyUpdateWithWhereUniqueWithoutChallengesInput {
  where: CompanyWhereUniqueInput;
  data: CompanyUpdateWithoutChallengesDataInput;
}

export interface CompanyUpdateWithoutChallengesDataInput {
  name?: Maybe<String>;
  type?: Maybe<CompanyType>;
  address?: Maybe<AddressUpdateOneInput>;
  users?: Maybe<UserUpdateManyWithoutCompanyInput>;
  emailDomains?: Maybe<CompanyUpdateemailDomainsInput>;
  stripeCustomerId?: Maybe<String>;
  quizzes?: Maybe<QuizUpdateManyWithoutCompaniesInput>;
}

export interface AddressUpdateOneInput {
  create?: Maybe<AddressCreateInput>;
  update?: Maybe<AddressUpdateDataInput>;
  upsert?: Maybe<AddressUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
}

export interface AddressUpdateDataInput {
  street?: Maybe<String>;
  zipCode?: Maybe<String>;
  city?: Maybe<String>;
}

export interface AddressUpsertNestedInput {
  update: AddressUpdateDataInput;
  create: AddressCreateInput;
}

export interface UserUpdateManyWithoutCompanyInput {
  create?: Maybe<
    UserCreateWithoutCompanyInput[] | UserCreateWithoutCompanyInput
  >;
  delete?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  set?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  disconnect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  update?: Maybe<
    | UserUpdateWithWhereUniqueWithoutCompanyInput[]
    | UserUpdateWithWhereUniqueWithoutCompanyInput
  >;
  upsert?: Maybe<
    | UserUpsertWithWhereUniqueWithoutCompanyInput[]
    | UserUpsertWithWhereUniqueWithoutCompanyInput
  >;
  deleteMany?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  updateMany?: Maybe<
    UserUpdateManyWithWhereNestedInput[] | UserUpdateManyWithWhereNestedInput
  >;
}

export interface UserUpdateWithWhereUniqueWithoutCompanyInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutCompanyDataInput;
}

export interface UserUpdateWithoutCompanyDataInput {
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  email?: Maybe<String>;
  phone?: Maybe<String>;
  password?: Maybe<String>;
  role?: Maybe<Role>;
  isRepresentative?: Maybe<Boolean>;
  points?: Maybe<Int>;
  validatedChallenges?: Maybe<ChallengeUpdateManyInput>;
  validatedQuizzes?: Maybe<QuizUpdateManyInput>;
}

export interface ChallengeUpdateManyInput {
  create?: Maybe<ChallengeCreateInput[] | ChallengeCreateInput>;
  update?: Maybe<
    | ChallengeUpdateWithWhereUniqueNestedInput[]
    | ChallengeUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | ChallengeUpsertWithWhereUniqueNestedInput[]
    | ChallengeUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<ChallengeWhereUniqueInput[] | ChallengeWhereUniqueInput>;
  connect?: Maybe<ChallengeWhereUniqueInput[] | ChallengeWhereUniqueInput>;
  set?: Maybe<ChallengeWhereUniqueInput[] | ChallengeWhereUniqueInput>;
  disconnect?: Maybe<ChallengeWhereUniqueInput[] | ChallengeWhereUniqueInput>;
  deleteMany?: Maybe<ChallengeScalarWhereInput[] | ChallengeScalarWhereInput>;
  updateMany?: Maybe<
    | ChallengeUpdateManyWithWhereNestedInput[]
    | ChallengeUpdateManyWithWhereNestedInput
  >;
}

export interface ChallengeUpdateWithWhereUniqueNestedInput {
  where: ChallengeWhereUniqueInput;
  data: ChallengeUpdateDataInput;
}

export interface ChallengeUpdateDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  value?: Maybe<Int>;
  companies?: Maybe<CompanyUpdateManyWithoutChallengesInput>;
}

export interface ChallengeUpsertWithWhereUniqueNestedInput {
  where: ChallengeWhereUniqueInput;
  update: ChallengeUpdateDataInput;
  create: ChallengeCreateInput;
}

export interface ChallengeScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  value?: Maybe<Int>;
  value_not?: Maybe<Int>;
  value_in?: Maybe<Int[] | Int>;
  value_not_in?: Maybe<Int[] | Int>;
  value_lt?: Maybe<Int>;
  value_lte?: Maybe<Int>;
  value_gt?: Maybe<Int>;
  value_gte?: Maybe<Int>;
  AND?: Maybe<ChallengeScalarWhereInput[] | ChallengeScalarWhereInput>;
  OR?: Maybe<ChallengeScalarWhereInput[] | ChallengeScalarWhereInput>;
  NOT?: Maybe<ChallengeScalarWhereInput[] | ChallengeScalarWhereInput>;
}

export interface ChallengeUpdateManyWithWhereNestedInput {
  where: ChallengeScalarWhereInput;
  data: ChallengeUpdateManyDataInput;
}

export interface ChallengeUpdateManyDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  value?: Maybe<Int>;
}

export interface QuizUpdateManyInput {
  create?: Maybe<QuizCreateInput[] | QuizCreateInput>;
  update?: Maybe<
    | QuizUpdateWithWhereUniqueNestedInput[]
    | QuizUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | QuizUpsertWithWhereUniqueNestedInput[]
    | QuizUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<QuizWhereUniqueInput[] | QuizWhereUniqueInput>;
  connect?: Maybe<QuizWhereUniqueInput[] | QuizWhereUniqueInput>;
  set?: Maybe<QuizWhereUniqueInput[] | QuizWhereUniqueInput>;
  disconnect?: Maybe<QuizWhereUniqueInput[] | QuizWhereUniqueInput>;
  deleteMany?: Maybe<QuizScalarWhereInput[] | QuizScalarWhereInput>;
  updateMany?: Maybe<
    QuizUpdateManyWithWhereNestedInput[] | QuizUpdateManyWithWhereNestedInput
  >;
}

export interface QuizUpdateWithWhereUniqueNestedInput {
  where: QuizWhereUniqueInput;
  data: QuizUpdateDataInput;
}

export interface QuizUpdateDataInput {
  name?: Maybe<String>;
  question?: Maybe<String>;
  choices?: Maybe<QuizUpdatechoicesInput>;
  answer?: Maybe<String>;
  value?: Maybe<Int>;
  companies?: Maybe<CompanyUpdateManyWithoutQuizzesInput>;
}

export interface QuizUpdatechoicesInput {
  set?: Maybe<String[] | String>;
}

export interface CompanyUpdateManyWithoutQuizzesInput {
  create?: Maybe<
    CompanyCreateWithoutQuizzesInput[] | CompanyCreateWithoutQuizzesInput
  >;
  delete?: Maybe<CompanyWhereUniqueInput[] | CompanyWhereUniqueInput>;
  connect?: Maybe<CompanyWhereUniqueInput[] | CompanyWhereUniqueInput>;
  set?: Maybe<CompanyWhereUniqueInput[] | CompanyWhereUniqueInput>;
  disconnect?: Maybe<CompanyWhereUniqueInput[] | CompanyWhereUniqueInput>;
  update?: Maybe<
    | CompanyUpdateWithWhereUniqueWithoutQuizzesInput[]
    | CompanyUpdateWithWhereUniqueWithoutQuizzesInput
  >;
  upsert?: Maybe<
    | CompanyUpsertWithWhereUniqueWithoutQuizzesInput[]
    | CompanyUpsertWithWhereUniqueWithoutQuizzesInput
  >;
  deleteMany?: Maybe<CompanyScalarWhereInput[] | CompanyScalarWhereInput>;
  updateMany?: Maybe<
    | CompanyUpdateManyWithWhereNestedInput[]
    | CompanyUpdateManyWithWhereNestedInput
  >;
}

export interface CompanyUpdateWithWhereUniqueWithoutQuizzesInput {
  where: CompanyWhereUniqueInput;
  data: CompanyUpdateWithoutQuizzesDataInput;
}

export interface CompanyUpdateWithoutQuizzesDataInput {
  name?: Maybe<String>;
  type?: Maybe<CompanyType>;
  address?: Maybe<AddressUpdateOneInput>;
  users?: Maybe<UserUpdateManyWithoutCompanyInput>;
  emailDomains?: Maybe<CompanyUpdateemailDomainsInput>;
  stripeCustomerId?: Maybe<String>;
  challenges?: Maybe<ChallengeUpdateManyWithoutCompaniesInput>;
}

export interface CompanyUpdateemailDomainsInput {
  set?: Maybe<String[] | String>;
}

export interface ChallengeUpdateManyWithoutCompaniesInput {
  create?: Maybe<
    | ChallengeCreateWithoutCompaniesInput[]
    | ChallengeCreateWithoutCompaniesInput
  >;
  delete?: Maybe<ChallengeWhereUniqueInput[] | ChallengeWhereUniqueInput>;
  connect?: Maybe<ChallengeWhereUniqueInput[] | ChallengeWhereUniqueInput>;
  set?: Maybe<ChallengeWhereUniqueInput[] | ChallengeWhereUniqueInput>;
  disconnect?: Maybe<ChallengeWhereUniqueInput[] | ChallengeWhereUniqueInput>;
  update?: Maybe<
    | ChallengeUpdateWithWhereUniqueWithoutCompaniesInput[]
    | ChallengeUpdateWithWhereUniqueWithoutCompaniesInput
  >;
  upsert?: Maybe<
    | ChallengeUpsertWithWhereUniqueWithoutCompaniesInput[]
    | ChallengeUpsertWithWhereUniqueWithoutCompaniesInput
  >;
  deleteMany?: Maybe<ChallengeScalarWhereInput[] | ChallengeScalarWhereInput>;
  updateMany?: Maybe<
    | ChallengeUpdateManyWithWhereNestedInput[]
    | ChallengeUpdateManyWithWhereNestedInput
  >;
}

export interface ChallengeUpdateWithWhereUniqueWithoutCompaniesInput {
  where: ChallengeWhereUniqueInput;
  data: ChallengeUpdateWithoutCompaniesDataInput;
}

export interface ChallengeUpdateWithoutCompaniesDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  value?: Maybe<Int>;
}

export interface ChallengeUpsertWithWhereUniqueWithoutCompaniesInput {
  where: ChallengeWhereUniqueInput;
  update: ChallengeUpdateWithoutCompaniesDataInput;
  create: ChallengeCreateWithoutCompaniesInput;
}

export interface CompanyUpsertWithWhereUniqueWithoutQuizzesInput {
  where: CompanyWhereUniqueInput;
  update: CompanyUpdateWithoutQuizzesDataInput;
  create: CompanyCreateWithoutQuizzesInput;
}

export interface CompanyScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  type?: Maybe<CompanyType>;
  type_not?: Maybe<CompanyType>;
  type_in?: Maybe<CompanyType[] | CompanyType>;
  type_not_in?: Maybe<CompanyType[] | CompanyType>;
  stripeCustomerId?: Maybe<String>;
  stripeCustomerId_not?: Maybe<String>;
  stripeCustomerId_in?: Maybe<String[] | String>;
  stripeCustomerId_not_in?: Maybe<String[] | String>;
  stripeCustomerId_lt?: Maybe<String>;
  stripeCustomerId_lte?: Maybe<String>;
  stripeCustomerId_gt?: Maybe<String>;
  stripeCustomerId_gte?: Maybe<String>;
  stripeCustomerId_contains?: Maybe<String>;
  stripeCustomerId_not_contains?: Maybe<String>;
  stripeCustomerId_starts_with?: Maybe<String>;
  stripeCustomerId_not_starts_with?: Maybe<String>;
  stripeCustomerId_ends_with?: Maybe<String>;
  stripeCustomerId_not_ends_with?: Maybe<String>;
  AND?: Maybe<CompanyScalarWhereInput[] | CompanyScalarWhereInput>;
  OR?: Maybe<CompanyScalarWhereInput[] | CompanyScalarWhereInput>;
  NOT?: Maybe<CompanyScalarWhereInput[] | CompanyScalarWhereInput>;
}

export interface CompanyUpdateManyWithWhereNestedInput {
  where: CompanyScalarWhereInput;
  data: CompanyUpdateManyDataInput;
}

export interface CompanyUpdateManyDataInput {
  name?: Maybe<String>;
  type?: Maybe<CompanyType>;
  emailDomains?: Maybe<CompanyUpdateemailDomainsInput>;
  stripeCustomerId?: Maybe<String>;
}

export interface QuizUpsertWithWhereUniqueNestedInput {
  where: QuizWhereUniqueInput;
  update: QuizUpdateDataInput;
  create: QuizCreateInput;
}

export interface QuizScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  question?: Maybe<String>;
  question_not?: Maybe<String>;
  question_in?: Maybe<String[] | String>;
  question_not_in?: Maybe<String[] | String>;
  question_lt?: Maybe<String>;
  question_lte?: Maybe<String>;
  question_gt?: Maybe<String>;
  question_gte?: Maybe<String>;
  question_contains?: Maybe<String>;
  question_not_contains?: Maybe<String>;
  question_starts_with?: Maybe<String>;
  question_not_starts_with?: Maybe<String>;
  question_ends_with?: Maybe<String>;
  question_not_ends_with?: Maybe<String>;
  answer?: Maybe<String>;
  answer_not?: Maybe<String>;
  answer_in?: Maybe<String[] | String>;
  answer_not_in?: Maybe<String[] | String>;
  answer_lt?: Maybe<String>;
  answer_lte?: Maybe<String>;
  answer_gt?: Maybe<String>;
  answer_gte?: Maybe<String>;
  answer_contains?: Maybe<String>;
  answer_not_contains?: Maybe<String>;
  answer_starts_with?: Maybe<String>;
  answer_not_starts_with?: Maybe<String>;
  answer_ends_with?: Maybe<String>;
  answer_not_ends_with?: Maybe<String>;
  value?: Maybe<Int>;
  value_not?: Maybe<Int>;
  value_in?: Maybe<Int[] | Int>;
  value_not_in?: Maybe<Int[] | Int>;
  value_lt?: Maybe<Int>;
  value_lte?: Maybe<Int>;
  value_gt?: Maybe<Int>;
  value_gte?: Maybe<Int>;
  AND?: Maybe<QuizScalarWhereInput[] | QuizScalarWhereInput>;
  OR?: Maybe<QuizScalarWhereInput[] | QuizScalarWhereInput>;
  NOT?: Maybe<QuizScalarWhereInput[] | QuizScalarWhereInput>;
}

export interface QuizUpdateManyWithWhereNestedInput {
  where: QuizScalarWhereInput;
  data: QuizUpdateManyDataInput;
}

export interface QuizUpdateManyDataInput {
  name?: Maybe<String>;
  question?: Maybe<String>;
  choices?: Maybe<QuizUpdatechoicesInput>;
  answer?: Maybe<String>;
  value?: Maybe<Int>;
}

export interface UserUpsertWithWhereUniqueWithoutCompanyInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutCompanyDataInput;
  create: UserCreateWithoutCompanyInput;
}

export interface UserScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  firstName?: Maybe<String>;
  firstName_not?: Maybe<String>;
  firstName_in?: Maybe<String[] | String>;
  firstName_not_in?: Maybe<String[] | String>;
  firstName_lt?: Maybe<String>;
  firstName_lte?: Maybe<String>;
  firstName_gt?: Maybe<String>;
  firstName_gte?: Maybe<String>;
  firstName_contains?: Maybe<String>;
  firstName_not_contains?: Maybe<String>;
  firstName_starts_with?: Maybe<String>;
  firstName_not_starts_with?: Maybe<String>;
  firstName_ends_with?: Maybe<String>;
  firstName_not_ends_with?: Maybe<String>;
  lastName?: Maybe<String>;
  lastName_not?: Maybe<String>;
  lastName_in?: Maybe<String[] | String>;
  lastName_not_in?: Maybe<String[] | String>;
  lastName_lt?: Maybe<String>;
  lastName_lte?: Maybe<String>;
  lastName_gt?: Maybe<String>;
  lastName_gte?: Maybe<String>;
  lastName_contains?: Maybe<String>;
  lastName_not_contains?: Maybe<String>;
  lastName_starts_with?: Maybe<String>;
  lastName_not_starts_with?: Maybe<String>;
  lastName_ends_with?: Maybe<String>;
  lastName_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  phone?: Maybe<String>;
  phone_not?: Maybe<String>;
  phone_in?: Maybe<String[] | String>;
  phone_not_in?: Maybe<String[] | String>;
  phone_lt?: Maybe<String>;
  phone_lte?: Maybe<String>;
  phone_gt?: Maybe<String>;
  phone_gte?: Maybe<String>;
  phone_contains?: Maybe<String>;
  phone_not_contains?: Maybe<String>;
  phone_starts_with?: Maybe<String>;
  phone_not_starts_with?: Maybe<String>;
  phone_ends_with?: Maybe<String>;
  phone_not_ends_with?: Maybe<String>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  role?: Maybe<Role>;
  role_not?: Maybe<Role>;
  role_in?: Maybe<Role[] | Role>;
  role_not_in?: Maybe<Role[] | Role>;
  isRepresentative?: Maybe<Boolean>;
  isRepresentative_not?: Maybe<Boolean>;
  points?: Maybe<Int>;
  points_not?: Maybe<Int>;
  points_in?: Maybe<Int[] | Int>;
  points_not_in?: Maybe<Int[] | Int>;
  points_lt?: Maybe<Int>;
  points_lte?: Maybe<Int>;
  points_gt?: Maybe<Int>;
  points_gte?: Maybe<Int>;
  AND?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  OR?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  NOT?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
}

export interface UserUpdateManyWithWhereNestedInput {
  where: UserScalarWhereInput;
  data: UserUpdateManyDataInput;
}

export interface UserUpdateManyDataInput {
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  email?: Maybe<String>;
  phone?: Maybe<String>;
  password?: Maybe<String>;
  role?: Maybe<Role>;
  isRepresentative?: Maybe<Boolean>;
  points?: Maybe<Int>;
}

export interface QuizUpdateManyWithoutCompaniesInput {
  create?: Maybe<
    QuizCreateWithoutCompaniesInput[] | QuizCreateWithoutCompaniesInput
  >;
  delete?: Maybe<QuizWhereUniqueInput[] | QuizWhereUniqueInput>;
  connect?: Maybe<QuizWhereUniqueInput[] | QuizWhereUniqueInput>;
  set?: Maybe<QuizWhereUniqueInput[] | QuizWhereUniqueInput>;
  disconnect?: Maybe<QuizWhereUniqueInput[] | QuizWhereUniqueInput>;
  update?: Maybe<
    | QuizUpdateWithWhereUniqueWithoutCompaniesInput[]
    | QuizUpdateWithWhereUniqueWithoutCompaniesInput
  >;
  upsert?: Maybe<
    | QuizUpsertWithWhereUniqueWithoutCompaniesInput[]
    | QuizUpsertWithWhereUniqueWithoutCompaniesInput
  >;
  deleteMany?: Maybe<QuizScalarWhereInput[] | QuizScalarWhereInput>;
  updateMany?: Maybe<
    QuizUpdateManyWithWhereNestedInput[] | QuizUpdateManyWithWhereNestedInput
  >;
}

export interface QuizUpdateWithWhereUniqueWithoutCompaniesInput {
  where: QuizWhereUniqueInput;
  data: QuizUpdateWithoutCompaniesDataInput;
}

export interface QuizUpdateWithoutCompaniesDataInput {
  name?: Maybe<String>;
  question?: Maybe<String>;
  choices?: Maybe<QuizUpdatechoicesInput>;
  answer?: Maybe<String>;
  value?: Maybe<Int>;
}

export interface QuizUpsertWithWhereUniqueWithoutCompaniesInput {
  where: QuizWhereUniqueInput;
  update: QuizUpdateWithoutCompaniesDataInput;
  create: QuizCreateWithoutCompaniesInput;
}

export interface CompanyUpsertWithWhereUniqueWithoutChallengesInput {
  where: CompanyWhereUniqueInput;
  update: CompanyUpdateWithoutChallengesDataInput;
  create: CompanyCreateWithoutChallengesInput;
}

export interface ChallengeUpdateManyMutationInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  value?: Maybe<Int>;
}

export interface CompanyCreateInput {
  id?: Maybe<ID_Input>;
  name?: Maybe<String>;
  type?: Maybe<CompanyType>;
  address?: Maybe<AddressCreateOneInput>;
  users?: Maybe<UserCreateManyWithoutCompanyInput>;
  emailDomains?: Maybe<CompanyCreateemailDomainsInput>;
  stripeCustomerId?: Maybe<String>;
  challenges?: Maybe<ChallengeCreateManyWithoutCompaniesInput>;
  quizzes?: Maybe<QuizCreateManyWithoutCompaniesInput>;
}

export interface CompanyUpdateInput {
  name?: Maybe<String>;
  type?: Maybe<CompanyType>;
  address?: Maybe<AddressUpdateOneInput>;
  users?: Maybe<UserUpdateManyWithoutCompanyInput>;
  emailDomains?: Maybe<CompanyUpdateemailDomainsInput>;
  stripeCustomerId?: Maybe<String>;
  challenges?: Maybe<ChallengeUpdateManyWithoutCompaniesInput>;
  quizzes?: Maybe<QuizUpdateManyWithoutCompaniesInput>;
}

export interface CompanyUpdateManyMutationInput {
  name?: Maybe<String>;
  type?: Maybe<CompanyType>;
  emailDomains?: Maybe<CompanyUpdateemailDomainsInput>;
  stripeCustomerId?: Maybe<String>;
}

export interface PhotoCreateInput {
  id?: Maybe<ID_Input>;
  url: String;
}

export interface PhotoUpdateInput {
  url?: Maybe<String>;
}

export interface PhotoUpdateManyMutationInput {
  url?: Maybe<String>;
}

export interface PlaceCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  category: Category;
  address?: Maybe<AddressCreateOneInput>;
  user?: Maybe<UserCreateOneInput>;
  social?: Maybe<SocialCreateOneInput>;
  headline?: Maybe<String>;
  description?: Maybe<String>;
  hours?: Maybe<HourCreateManyInput>;
  tags?: Maybe<TagCreateManyInput>;
  photos?: Maybe<PhotoCreateManyInput>;
}

export interface UserCreateOneInput {
  create?: Maybe<UserCreateInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateInput {
  id?: Maybe<ID_Input>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  email?: Maybe<String>;
  phone?: Maybe<String>;
  password?: Maybe<String>;
  role?: Maybe<Role>;
  isRepresentative?: Maybe<Boolean>;
  company?: Maybe<CompanyCreateOneWithoutUsersInput>;
  points?: Maybe<Int>;
  validatedChallenges?: Maybe<ChallengeCreateManyInput>;
  validatedQuizzes?: Maybe<QuizCreateManyInput>;
}

export interface CompanyCreateOneWithoutUsersInput {
  create?: Maybe<CompanyCreateWithoutUsersInput>;
  connect?: Maybe<CompanyWhereUniqueInput>;
}

export interface CompanyCreateWithoutUsersInput {
  id?: Maybe<ID_Input>;
  name?: Maybe<String>;
  type?: Maybe<CompanyType>;
  address?: Maybe<AddressCreateOneInput>;
  emailDomains?: Maybe<CompanyCreateemailDomainsInput>;
  stripeCustomerId?: Maybe<String>;
  challenges?: Maybe<ChallengeCreateManyWithoutCompaniesInput>;
  quizzes?: Maybe<QuizCreateManyWithoutCompaniesInput>;
}

export interface SocialCreateOneInput {
  create?: Maybe<SocialCreateInput>;
}

export interface SocialCreateInput {
  website?: Maybe<String>;
  facebook?: Maybe<String>;
  instagram?: Maybe<String>;
}

export interface HourCreateManyInput {
  create?: Maybe<HourCreateInput[] | HourCreateInput>;
}

export interface HourCreateInput {
  day?: Maybe<Day>;
  start?: Maybe<String>;
  end?: Maybe<String>;
}

export interface TagCreateManyInput {
  create?: Maybe<TagCreateInput[] | TagCreateInput>;
  connect?: Maybe<TagWhereUniqueInput[] | TagWhereUniqueInput>;
}

export interface TagCreateInput {
  id?: Maybe<ID_Input>;
  label: String;
  children?: Maybe<TagCreateManyInput>;
  root?: Maybe<Boolean>;
  leaf?: Maybe<Boolean>;
  category: Category;
}

export interface PhotoCreateManyInput {
  create?: Maybe<PhotoCreateInput[] | PhotoCreateInput>;
  connect?: Maybe<PhotoWhereUniqueInput[] | PhotoWhereUniqueInput>;
}

export interface PlaceUpdateInput {
  name?: Maybe<String>;
  category?: Maybe<Category>;
  address?: Maybe<AddressUpdateOneInput>;
  user?: Maybe<UserUpdateOneInput>;
  social?: Maybe<SocialUpdateOneInput>;
  headline?: Maybe<String>;
  description?: Maybe<String>;
  hours?: Maybe<HourUpdateManyInput>;
  tags?: Maybe<TagUpdateManyInput>;
  photos?: Maybe<PhotoUpdateManyInput>;
}

export interface UserUpdateOneInput {
  create?: Maybe<UserCreateInput>;
  update?: Maybe<UserUpdateDataInput>;
  upsert?: Maybe<UserUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateDataInput {
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  email?: Maybe<String>;
  phone?: Maybe<String>;
  password?: Maybe<String>;
  role?: Maybe<Role>;
  isRepresentative?: Maybe<Boolean>;
  company?: Maybe<CompanyUpdateOneWithoutUsersInput>;
  points?: Maybe<Int>;
  validatedChallenges?: Maybe<ChallengeUpdateManyInput>;
  validatedQuizzes?: Maybe<QuizUpdateManyInput>;
}

export interface CompanyUpdateOneWithoutUsersInput {
  create?: Maybe<CompanyCreateWithoutUsersInput>;
  update?: Maybe<CompanyUpdateWithoutUsersDataInput>;
  upsert?: Maybe<CompanyUpsertWithoutUsersInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<CompanyWhereUniqueInput>;
}

export interface CompanyUpdateWithoutUsersDataInput {
  name?: Maybe<String>;
  type?: Maybe<CompanyType>;
  address?: Maybe<AddressUpdateOneInput>;
  emailDomains?: Maybe<CompanyUpdateemailDomainsInput>;
  stripeCustomerId?: Maybe<String>;
  challenges?: Maybe<ChallengeUpdateManyWithoutCompaniesInput>;
  quizzes?: Maybe<QuizUpdateManyWithoutCompaniesInput>;
}

export interface CompanyUpsertWithoutUsersInput {
  update: CompanyUpdateWithoutUsersDataInput;
  create: CompanyCreateWithoutUsersInput;
}

export interface UserUpsertNestedInput {
  update: UserUpdateDataInput;
  create: UserCreateInput;
}

export interface SocialUpdateOneInput {
  create?: Maybe<SocialCreateInput>;
  update?: Maybe<SocialUpdateDataInput>;
  upsert?: Maybe<SocialUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
}

export interface SocialUpdateDataInput {
  website?: Maybe<String>;
  facebook?: Maybe<String>;
  instagram?: Maybe<String>;
}

export interface SocialUpsertNestedInput {
  update: SocialUpdateDataInput;
  create: SocialCreateInput;
}

export interface HourUpdateManyInput {
  create?: Maybe<HourCreateInput[] | HourCreateInput>;
  deleteMany?: Maybe<HourScalarWhereInput[] | HourScalarWhereInput>;
  updateMany?: Maybe<
    HourUpdateManyWithWhereNestedInput[] | HourUpdateManyWithWhereNestedInput
  >;
}

export interface HourScalarWhereInput {
  day?: Maybe<Day>;
  day_not?: Maybe<Day>;
  day_in?: Maybe<Day[] | Day>;
  day_not_in?: Maybe<Day[] | Day>;
  start?: Maybe<String>;
  start_not?: Maybe<String>;
  start_in?: Maybe<String[] | String>;
  start_not_in?: Maybe<String[] | String>;
  start_lt?: Maybe<String>;
  start_lte?: Maybe<String>;
  start_gt?: Maybe<String>;
  start_gte?: Maybe<String>;
  start_contains?: Maybe<String>;
  start_not_contains?: Maybe<String>;
  start_starts_with?: Maybe<String>;
  start_not_starts_with?: Maybe<String>;
  start_ends_with?: Maybe<String>;
  start_not_ends_with?: Maybe<String>;
  end?: Maybe<String>;
  end_not?: Maybe<String>;
  end_in?: Maybe<String[] | String>;
  end_not_in?: Maybe<String[] | String>;
  end_lt?: Maybe<String>;
  end_lte?: Maybe<String>;
  end_gt?: Maybe<String>;
  end_gte?: Maybe<String>;
  end_contains?: Maybe<String>;
  end_not_contains?: Maybe<String>;
  end_starts_with?: Maybe<String>;
  end_not_starts_with?: Maybe<String>;
  end_ends_with?: Maybe<String>;
  end_not_ends_with?: Maybe<String>;
  AND?: Maybe<HourScalarWhereInput[] | HourScalarWhereInput>;
  OR?: Maybe<HourScalarWhereInput[] | HourScalarWhereInput>;
  NOT?: Maybe<HourScalarWhereInput[] | HourScalarWhereInput>;
}

export interface HourUpdateManyWithWhereNestedInput {
  where: HourScalarWhereInput;
  data: HourUpdateManyDataInput;
}

export interface HourUpdateManyDataInput {
  day?: Maybe<Day>;
  start?: Maybe<String>;
  end?: Maybe<String>;
}

export interface TagUpdateManyInput {
  create?: Maybe<TagCreateInput[] | TagCreateInput>;
  update?: Maybe<
    TagUpdateWithWhereUniqueNestedInput[] | TagUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    TagUpsertWithWhereUniqueNestedInput[] | TagUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<TagWhereUniqueInput[] | TagWhereUniqueInput>;
  connect?: Maybe<TagWhereUniqueInput[] | TagWhereUniqueInput>;
  set?: Maybe<TagWhereUniqueInput[] | TagWhereUniqueInput>;
  disconnect?: Maybe<TagWhereUniqueInput[] | TagWhereUniqueInput>;
  deleteMany?: Maybe<TagScalarWhereInput[] | TagScalarWhereInput>;
  updateMany?: Maybe<
    TagUpdateManyWithWhereNestedInput[] | TagUpdateManyWithWhereNestedInput
  >;
}

export interface TagUpdateWithWhereUniqueNestedInput {
  where: TagWhereUniqueInput;
  data: TagUpdateDataInput;
}

export interface TagUpdateDataInput {
  label?: Maybe<String>;
  children?: Maybe<TagUpdateManyInput>;
  root?: Maybe<Boolean>;
  leaf?: Maybe<Boolean>;
  category?: Maybe<Category>;
}

export interface TagUpsertWithWhereUniqueNestedInput {
  where: TagWhereUniqueInput;
  update: TagUpdateDataInput;
  create: TagCreateInput;
}

export interface TagScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  label?: Maybe<String>;
  label_not?: Maybe<String>;
  label_in?: Maybe<String[] | String>;
  label_not_in?: Maybe<String[] | String>;
  label_lt?: Maybe<String>;
  label_lte?: Maybe<String>;
  label_gt?: Maybe<String>;
  label_gte?: Maybe<String>;
  label_contains?: Maybe<String>;
  label_not_contains?: Maybe<String>;
  label_starts_with?: Maybe<String>;
  label_not_starts_with?: Maybe<String>;
  label_ends_with?: Maybe<String>;
  label_not_ends_with?: Maybe<String>;
  root?: Maybe<Boolean>;
  root_not?: Maybe<Boolean>;
  leaf?: Maybe<Boolean>;
  leaf_not?: Maybe<Boolean>;
  category?: Maybe<Category>;
  category_not?: Maybe<Category>;
  category_in?: Maybe<Category[] | Category>;
  category_not_in?: Maybe<Category[] | Category>;
  AND?: Maybe<TagScalarWhereInput[] | TagScalarWhereInput>;
  OR?: Maybe<TagScalarWhereInput[] | TagScalarWhereInput>;
  NOT?: Maybe<TagScalarWhereInput[] | TagScalarWhereInput>;
}

export interface TagUpdateManyWithWhereNestedInput {
  where: TagScalarWhereInput;
  data: TagUpdateManyDataInput;
}

export interface TagUpdateManyDataInput {
  label?: Maybe<String>;
  root?: Maybe<Boolean>;
  leaf?: Maybe<Boolean>;
  category?: Maybe<Category>;
}

export interface PhotoUpdateManyInput {
  create?: Maybe<PhotoCreateInput[] | PhotoCreateInput>;
  update?: Maybe<
    | PhotoUpdateWithWhereUniqueNestedInput[]
    | PhotoUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | PhotoUpsertWithWhereUniqueNestedInput[]
    | PhotoUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<PhotoWhereUniqueInput[] | PhotoWhereUniqueInput>;
  connect?: Maybe<PhotoWhereUniqueInput[] | PhotoWhereUniqueInput>;
  set?: Maybe<PhotoWhereUniqueInput[] | PhotoWhereUniqueInput>;
  disconnect?: Maybe<PhotoWhereUniqueInput[] | PhotoWhereUniqueInput>;
  deleteMany?: Maybe<PhotoScalarWhereInput[] | PhotoScalarWhereInput>;
  updateMany?: Maybe<
    PhotoUpdateManyWithWhereNestedInput[] | PhotoUpdateManyWithWhereNestedInput
  >;
}

export interface PhotoUpdateWithWhereUniqueNestedInput {
  where: PhotoWhereUniqueInput;
  data: PhotoUpdateDataInput;
}

export interface PhotoUpdateDataInput {
  url?: Maybe<String>;
}

export interface PhotoUpsertWithWhereUniqueNestedInput {
  where: PhotoWhereUniqueInput;
  update: PhotoUpdateDataInput;
  create: PhotoCreateInput;
}

export interface PhotoScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  url?: Maybe<String>;
  url_not?: Maybe<String>;
  url_in?: Maybe<String[] | String>;
  url_not_in?: Maybe<String[] | String>;
  url_lt?: Maybe<String>;
  url_lte?: Maybe<String>;
  url_gt?: Maybe<String>;
  url_gte?: Maybe<String>;
  url_contains?: Maybe<String>;
  url_not_contains?: Maybe<String>;
  url_starts_with?: Maybe<String>;
  url_not_starts_with?: Maybe<String>;
  url_ends_with?: Maybe<String>;
  url_not_ends_with?: Maybe<String>;
  AND?: Maybe<PhotoScalarWhereInput[] | PhotoScalarWhereInput>;
  OR?: Maybe<PhotoScalarWhereInput[] | PhotoScalarWhereInput>;
  NOT?: Maybe<PhotoScalarWhereInput[] | PhotoScalarWhereInput>;
}

export interface PhotoUpdateManyWithWhereNestedInput {
  where: PhotoScalarWhereInput;
  data: PhotoUpdateManyDataInput;
}

export interface PhotoUpdateManyDataInput {
  url?: Maybe<String>;
}

export interface PlaceUpdateManyMutationInput {
  name?: Maybe<String>;
  category?: Maybe<Category>;
  headline?: Maybe<String>;
  description?: Maybe<String>;
}

export interface QuizUpdateInput {
  name?: Maybe<String>;
  question?: Maybe<String>;
  choices?: Maybe<QuizUpdatechoicesInput>;
  answer?: Maybe<String>;
  value?: Maybe<Int>;
  companies?: Maybe<CompanyUpdateManyWithoutQuizzesInput>;
}

export interface QuizUpdateManyMutationInput {
  name?: Maybe<String>;
  question?: Maybe<String>;
  choices?: Maybe<QuizUpdatechoicesInput>;
  answer?: Maybe<String>;
  value?: Maybe<Int>;
}

export interface TagUpdateInput {
  label?: Maybe<String>;
  children?: Maybe<TagUpdateManyInput>;
  root?: Maybe<Boolean>;
  leaf?: Maybe<Boolean>;
  category?: Maybe<Category>;
}

export interface TagUpdateManyMutationInput {
  label?: Maybe<String>;
  root?: Maybe<Boolean>;
  leaf?: Maybe<Boolean>;
  category?: Maybe<Category>;
}

export interface UserUpdateInput {
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  email?: Maybe<String>;
  phone?: Maybe<String>;
  password?: Maybe<String>;
  role?: Maybe<Role>;
  isRepresentative?: Maybe<Boolean>;
  company?: Maybe<CompanyUpdateOneWithoutUsersInput>;
  points?: Maybe<Int>;
  validatedChallenges?: Maybe<ChallengeUpdateManyInput>;
  validatedQuizzes?: Maybe<QuizUpdateManyInput>;
}

export interface UserUpdateManyMutationInput {
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  email?: Maybe<String>;
  phone?: Maybe<String>;
  password?: Maybe<String>;
  role?: Maybe<Role>;
  isRepresentative?: Maybe<Boolean>;
  points?: Maybe<Int>;
}

export interface ChallengeSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ChallengeWhereInput>;
  AND?: Maybe<
    ChallengeSubscriptionWhereInput[] | ChallengeSubscriptionWhereInput
  >;
}

export interface CompanySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CompanyWhereInput>;
  AND?: Maybe<CompanySubscriptionWhereInput[] | CompanySubscriptionWhereInput>;
}

export interface PhotoSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PhotoWhereInput>;
  AND?: Maybe<PhotoSubscriptionWhereInput[] | PhotoSubscriptionWhereInput>;
}

export interface PlaceSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PlaceWhereInput>;
  AND?: Maybe<PlaceSubscriptionWhereInput[] | PlaceSubscriptionWhereInput>;
}

export interface QuizSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<QuizWhereInput>;
  AND?: Maybe<QuizSubscriptionWhereInput[] | QuizSubscriptionWhereInput>;
}

export interface TagSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<TagWhereInput>;
  AND?: Maybe<TagSubscriptionWhereInput[] | TagSubscriptionWhereInput>;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserWhereInput>;
  AND?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
}

export interface NodeNode {
  id: ID_Output;
}

export interface Challenge {
  id: ID_Output;
  name: String;
  description: String;
  value: Int;
}

export interface ChallengePromise extends Promise<Challenge>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  value: () => Promise<Int>;
  companies: <T = FragmentableArray<Company>>(args?: {
    where?: CompanyWhereInput;
    orderBy?: CompanyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ChallengeSubscription
  extends Promise<AsyncIterator<Challenge>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  value: () => Promise<AsyncIterator<Int>>;
  companies: <T = Promise<AsyncIterator<CompanySubscription>>>(args?: {
    where?: CompanyWhereInput;
    orderBy?: CompanyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ChallengeNullablePromise
  extends Promise<Challenge | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  value: () => Promise<Int>;
  companies: <T = FragmentableArray<Company>>(args?: {
    where?: CompanyWhereInput;
    orderBy?: CompanyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface Company {
  id: ID_Output;
  name?: String;
  type?: CompanyType;
  address?: Address | null;
  emailDomains: String[];
  stripeCustomerId?: String;
}

export interface CompanyPromise extends Promise<Company>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  type: () => Promise<CompanyType>;
  address: <T = AddressPromise>() => T;
  users: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  emailDomains: () => Promise<String[]>;
  stripeCustomerId: () => Promise<String>;
  challenges: <T = FragmentableArray<Challenge>>(args?: {
    where?: ChallengeWhereInput;
    orderBy?: ChallengeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  quizzes: <T = FragmentableArray<Quiz>>(args?: {
    where?: QuizWhereInput;
    orderBy?: QuizOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface CompanySubscription
  extends Promise<AsyncIterator<Company>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<CompanyType>>;
  address: <T = AddressSubscription>() => T;
  users: <T = Promise<AsyncIterator<UserSubscription>>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  emailDomains: () => Promise<AsyncIterator<String[]>>;
  stripeCustomerId: () => Promise<AsyncIterator<String>>;
  challenges: <T = Promise<AsyncIterator<ChallengeSubscription>>>(args?: {
    where?: ChallengeWhereInput;
    orderBy?: ChallengeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  quizzes: <T = Promise<AsyncIterator<QuizSubscription>>>(args?: {
    where?: QuizWhereInput;
    orderBy?: QuizOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface CompanyNullablePromise
  extends Promise<Company | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  type: () => Promise<CompanyType>;
  address: <T = AddressPromise>() => T;
  users: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  emailDomains: () => Promise<String[]>;
  stripeCustomerId: () => Promise<String>;
  challenges: <T = FragmentableArray<Challenge>>(args?: {
    where?: ChallengeWhereInput;
    orderBy?: ChallengeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  quizzes: <T = FragmentableArray<Quiz>>(args?: {
    where?: QuizWhereInput;
    orderBy?: QuizOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface Address {
  street?: String;
  zipCode?: String;
  city?: String;
}

export interface AddressPromise extends Promise<Address>, Fragmentable {
  street: () => Promise<String>;
  zipCode: () => Promise<String>;
  city: () => Promise<String>;
}

export interface AddressSubscription
  extends Promise<AsyncIterator<Address>>,
    Fragmentable {
  street: () => Promise<AsyncIterator<String>>;
  zipCode: () => Promise<AsyncIterator<String>>;
  city: () => Promise<AsyncIterator<String>>;
}

export interface AddressNullablePromise
  extends Promise<Address | null>,
    Fragmentable {
  street: () => Promise<String>;
  zipCode: () => Promise<String>;
  city: () => Promise<String>;
}

export interface User {
  id: ID_Output;
  firstName?: String;
  lastName?: String;
  email?: String;
  phone?: String;
  password?: String;
  role?: Role;
  isRepresentative?: Boolean;
  points?: Int;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  email: () => Promise<String>;
  phone: () => Promise<String>;
  password: () => Promise<String>;
  role: () => Promise<Role>;
  isRepresentative: () => Promise<Boolean>;
  company: <T = CompanyPromise>() => T;
  points: () => Promise<Int>;
  validatedChallenges: <T = FragmentableArray<Challenge>>(args?: {
    where?: ChallengeWhereInput;
    orderBy?: ChallengeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  validatedQuizzes: <T = FragmentableArray<Quiz>>(args?: {
    where?: QuizWhereInput;
    orderBy?: QuizOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  role: () => Promise<AsyncIterator<Role>>;
  isRepresentative: () => Promise<AsyncIterator<Boolean>>;
  company: <T = CompanySubscription>() => T;
  points: () => Promise<AsyncIterator<Int>>;
  validatedChallenges: <
    T = Promise<AsyncIterator<ChallengeSubscription>>
  >(args?: {
    where?: ChallengeWhereInput;
    orderBy?: ChallengeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  validatedQuizzes: <T = Promise<AsyncIterator<QuizSubscription>>>(args?: {
    where?: QuizWhereInput;
    orderBy?: QuizOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface UserNullablePromise
  extends Promise<User | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  email: () => Promise<String>;
  phone: () => Promise<String>;
  password: () => Promise<String>;
  role: () => Promise<Role>;
  isRepresentative: () => Promise<Boolean>;
  company: <T = CompanyPromise>() => T;
  points: () => Promise<Int>;
  validatedChallenges: <T = FragmentableArray<Challenge>>(args?: {
    where?: ChallengeWhereInput;
    orderBy?: ChallengeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  validatedQuizzes: <T = FragmentableArray<Quiz>>(args?: {
    where?: QuizWhereInput;
    orderBy?: QuizOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface Quiz {
  id: ID_Output;
  name: String;
  question: String;
  choices: String[];
  answer: String;
  value: Int;
}

export interface QuizPromise extends Promise<Quiz>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  question: () => Promise<String>;
  choices: () => Promise<String[]>;
  answer: () => Promise<String>;
  value: () => Promise<Int>;
  companies: <T = FragmentableArray<Company>>(args?: {
    where?: CompanyWhereInput;
    orderBy?: CompanyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface QuizSubscription
  extends Promise<AsyncIterator<Quiz>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  question: () => Promise<AsyncIterator<String>>;
  choices: () => Promise<AsyncIterator<String[]>>;
  answer: () => Promise<AsyncIterator<String>>;
  value: () => Promise<AsyncIterator<Int>>;
  companies: <T = Promise<AsyncIterator<CompanySubscription>>>(args?: {
    where?: CompanyWhereInput;
    orderBy?: CompanyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface QuizNullablePromise
  extends Promise<Quiz | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  question: () => Promise<String>;
  choices: () => Promise<String[]>;
  answer: () => Promise<String>;
  value: () => Promise<Int>;
  companies: <T = FragmentableArray<Company>>(args?: {
    where?: CompanyWhereInput;
    orderBy?: CompanyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ChallengeConnection {
  pageInfo: PageInfo;
  edges: ChallengeEdge[];
}

export interface ChallengeConnectionPromise
  extends Promise<ChallengeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ChallengeEdge>>() => T;
  aggregate: <T = AggregateChallengePromise>() => T;
}

export interface ChallengeConnectionSubscription
  extends Promise<AsyncIterator<ChallengeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ChallengeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateChallengeSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface ChallengeEdge {
  node: Challenge;
  cursor: String;
}

export interface ChallengeEdgePromise
  extends Promise<ChallengeEdge>,
    Fragmentable {
  node: <T = ChallengePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ChallengeEdgeSubscription
  extends Promise<AsyncIterator<ChallengeEdge>>,
    Fragmentable {
  node: <T = ChallengeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateChallenge {
  count: Int;
}

export interface AggregateChallengePromise
  extends Promise<AggregateChallenge>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateChallengeSubscription
  extends Promise<AsyncIterator<AggregateChallenge>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CompanyConnection {
  pageInfo: PageInfo;
  edges: CompanyEdge[];
}

export interface CompanyConnectionPromise
  extends Promise<CompanyConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CompanyEdge>>() => T;
  aggregate: <T = AggregateCompanyPromise>() => T;
}

export interface CompanyConnectionSubscription
  extends Promise<AsyncIterator<CompanyConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CompanyEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCompanySubscription>() => T;
}

export interface CompanyEdge {
  node: Company;
  cursor: String;
}

export interface CompanyEdgePromise extends Promise<CompanyEdge>, Fragmentable {
  node: <T = CompanyPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CompanyEdgeSubscription
  extends Promise<AsyncIterator<CompanyEdge>>,
    Fragmentable {
  node: <T = CompanySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCompany {
  count: Int;
}

export interface AggregateCompanyPromise
  extends Promise<AggregateCompany>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCompanySubscription
  extends Promise<AsyncIterator<AggregateCompany>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Photo {
  id: ID_Output;
  url: String;
}

export interface PhotoPromise extends Promise<Photo>, Fragmentable {
  id: () => Promise<ID_Output>;
  url: () => Promise<String>;
}

export interface PhotoSubscription
  extends Promise<AsyncIterator<Photo>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  url: () => Promise<AsyncIterator<String>>;
}

export interface PhotoNullablePromise
  extends Promise<Photo | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  url: () => Promise<String>;
}

export interface PhotoConnection {
  pageInfo: PageInfo;
  edges: PhotoEdge[];
}

export interface PhotoConnectionPromise
  extends Promise<PhotoConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PhotoEdge>>() => T;
  aggregate: <T = AggregatePhotoPromise>() => T;
}

export interface PhotoConnectionSubscription
  extends Promise<AsyncIterator<PhotoConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PhotoEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePhotoSubscription>() => T;
}

export interface PhotoEdge {
  node: Photo;
  cursor: String;
}

export interface PhotoEdgePromise extends Promise<PhotoEdge>, Fragmentable {
  node: <T = PhotoPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PhotoEdgeSubscription
  extends Promise<AsyncIterator<PhotoEdge>>,
    Fragmentable {
  node: <T = PhotoSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePhoto {
  count: Int;
}

export interface AggregatePhotoPromise
  extends Promise<AggregatePhoto>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePhotoSubscription
  extends Promise<AsyncIterator<AggregatePhoto>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Place {
  id: ID_Output;
  name: String;
  category: Category;
  address?: Address | null;
  social?: Social | null;
  headline?: String;
  description?: String;
  hours?: <T = FragmentableArray<Hour>>() => T;
}

export interface PlacePromise extends Promise<Place>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  category: () => Promise<Category>;
  address: <T = AddressPromise>() => T;
  user: <T = UserPromise>() => T;
  social: <T = SocialPromise>() => T;
  headline: () => Promise<String>;
  description: () => Promise<String>;
  hours: <T = FragmentableArray<Hour>>() => T;
  tags: <T = FragmentableArray<Tag>>(args?: {
    where?: TagWhereInput;
    orderBy?: TagOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  photos: <T = FragmentableArray<Photo>>(args?: {
    where?: PhotoWhereInput;
    orderBy?: PhotoOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface PlaceSubscription
  extends Promise<AsyncIterator<Place>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  category: () => Promise<AsyncIterator<Category>>;
  address: <T = AddressSubscription>() => T;
  user: <T = UserSubscription>() => T;
  social: <T = SocialSubscription>() => T;
  headline: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  hours: <T = Promise<AsyncIterator<HourSubscription>>>() => T;
  tags: <T = Promise<AsyncIterator<TagSubscription>>>(args?: {
    where?: TagWhereInput;
    orderBy?: TagOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  photos: <T = Promise<AsyncIterator<PhotoSubscription>>>(args?: {
    where?: PhotoWhereInput;
    orderBy?: PhotoOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface PlaceNullablePromise
  extends Promise<Place | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  category: () => Promise<Category>;
  address: <T = AddressPromise>() => T;
  user: <T = UserPromise>() => T;
  social: <T = SocialPromise>() => T;
  headline: () => Promise<String>;
  description: () => Promise<String>;
  hours: <T = FragmentableArray<Hour>>() => T;
  tags: <T = FragmentableArray<Tag>>(args?: {
    where?: TagWhereInput;
    orderBy?: TagOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  photos: <T = FragmentableArray<Photo>>(args?: {
    where?: PhotoWhereInput;
    orderBy?: PhotoOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface Social {
  website?: String;
  facebook?: String;
  instagram?: String;
}

export interface SocialPromise extends Promise<Social>, Fragmentable {
  website: () => Promise<String>;
  facebook: () => Promise<String>;
  instagram: () => Promise<String>;
}

export interface SocialSubscription
  extends Promise<AsyncIterator<Social>>,
    Fragmentable {
  website: () => Promise<AsyncIterator<String>>;
  facebook: () => Promise<AsyncIterator<String>>;
  instagram: () => Promise<AsyncIterator<String>>;
}

export interface SocialNullablePromise
  extends Promise<Social | null>,
    Fragmentable {
  website: () => Promise<String>;
  facebook: () => Promise<String>;
  instagram: () => Promise<String>;
}

export interface Hour {
  day?: Day;
  start?: String;
  end?: String;
}

export interface HourPromise extends Promise<Hour>, Fragmentable {
  day: () => Promise<Day>;
  start: () => Promise<String>;
  end: () => Promise<String>;
}

export interface HourSubscription
  extends Promise<AsyncIterator<Hour>>,
    Fragmentable {
  day: () => Promise<AsyncIterator<Day>>;
  start: () => Promise<AsyncIterator<String>>;
  end: () => Promise<AsyncIterator<String>>;
}

export interface HourNullablePromise
  extends Promise<Hour | null>,
    Fragmentable {
  day: () => Promise<Day>;
  start: () => Promise<String>;
  end: () => Promise<String>;
}

export interface Tag {
  id: ID_Output;
  label: String;
  root?: Boolean;
  leaf?: Boolean;
  category: Category;
}

export interface TagPromise extends Promise<Tag>, Fragmentable {
  id: () => Promise<ID_Output>;
  label: () => Promise<String>;
  children: <T = FragmentableArray<Tag>>(args?: {
    where?: TagWhereInput;
    orderBy?: TagOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  root: () => Promise<Boolean>;
  leaf: () => Promise<Boolean>;
  category: () => Promise<Category>;
}

export interface TagSubscription
  extends Promise<AsyncIterator<Tag>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  label: () => Promise<AsyncIterator<String>>;
  children: <T = Promise<AsyncIterator<TagSubscription>>>(args?: {
    where?: TagWhereInput;
    orderBy?: TagOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  root: () => Promise<AsyncIterator<Boolean>>;
  leaf: () => Promise<AsyncIterator<Boolean>>;
  category: () => Promise<AsyncIterator<Category>>;
}

export interface TagNullablePromise extends Promise<Tag | null>, Fragmentable {
  id: () => Promise<ID_Output>;
  label: () => Promise<String>;
  children: <T = FragmentableArray<Tag>>(args?: {
    where?: TagWhereInput;
    orderBy?: TagOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  root: () => Promise<Boolean>;
  leaf: () => Promise<Boolean>;
  category: () => Promise<Category>;
}

export interface PlaceConnection {
  pageInfo: PageInfo;
  edges: PlaceEdge[];
}

export interface PlaceConnectionPromise
  extends Promise<PlaceConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PlaceEdge>>() => T;
  aggregate: <T = AggregatePlacePromise>() => T;
}

export interface PlaceConnectionSubscription
  extends Promise<AsyncIterator<PlaceConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PlaceEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePlaceSubscription>() => T;
}

export interface PlaceEdge {
  node: Place;
  cursor: String;
}

export interface PlaceEdgePromise extends Promise<PlaceEdge>, Fragmentable {
  node: <T = PlacePromise>() => T;
  cursor: () => Promise<String>;
}

export interface PlaceEdgeSubscription
  extends Promise<AsyncIterator<PlaceEdge>>,
    Fragmentable {
  node: <T = PlaceSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePlace {
  count: Int;
}

export interface AggregatePlacePromise
  extends Promise<AggregatePlace>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePlaceSubscription
  extends Promise<AsyncIterator<AggregatePlace>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface QuizConnection {
  pageInfo: PageInfo;
  edges: QuizEdge[];
}

export interface QuizConnectionPromise
  extends Promise<QuizConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<QuizEdge>>() => T;
  aggregate: <T = AggregateQuizPromise>() => T;
}

export interface QuizConnectionSubscription
  extends Promise<AsyncIterator<QuizConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<QuizEdgeSubscription>>>() => T;
  aggregate: <T = AggregateQuizSubscription>() => T;
}

export interface QuizEdge {
  node: Quiz;
  cursor: String;
}

export interface QuizEdgePromise extends Promise<QuizEdge>, Fragmentable {
  node: <T = QuizPromise>() => T;
  cursor: () => Promise<String>;
}

export interface QuizEdgeSubscription
  extends Promise<AsyncIterator<QuizEdge>>,
    Fragmentable {
  node: <T = QuizSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateQuiz {
  count: Int;
}

export interface AggregateQuizPromise
  extends Promise<AggregateQuiz>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateQuizSubscription
  extends Promise<AsyncIterator<AggregateQuiz>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TagConnection {
  pageInfo: PageInfo;
  edges: TagEdge[];
}

export interface TagConnectionPromise
  extends Promise<TagConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TagEdge>>() => T;
  aggregate: <T = AggregateTagPromise>() => T;
}

export interface TagConnectionSubscription
  extends Promise<AsyncIterator<TagConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TagEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTagSubscription>() => T;
}

export interface TagEdge {
  node: Tag;
  cursor: String;
}

export interface TagEdgePromise extends Promise<TagEdge>, Fragmentable {
  node: <T = TagPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TagEdgeSubscription
  extends Promise<AsyncIterator<TagEdge>>,
    Fragmentable {
  node: <T = TagSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateTag {
  count: Int;
}

export interface AggregateTagPromise
  extends Promise<AggregateTag>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTagSubscription
  extends Promise<AsyncIterator<AggregateTag>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface ChallengeSubscriptionPayload {
  mutation: MutationType;
  node: Challenge;
  updatedFields: String[];
  previousValues: ChallengePreviousValues;
}

export interface ChallengeSubscriptionPayloadPromise
  extends Promise<ChallengeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ChallengePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ChallengePreviousValuesPromise>() => T;
}

export interface ChallengeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ChallengeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ChallengeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ChallengePreviousValuesSubscription>() => T;
}

export interface ChallengePreviousValues {
  id: ID_Output;
  name: String;
  description: String;
  value: Int;
}

export interface ChallengePreviousValuesPromise
  extends Promise<ChallengePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  value: () => Promise<Int>;
}

export interface ChallengePreviousValuesSubscription
  extends Promise<AsyncIterator<ChallengePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  value: () => Promise<AsyncIterator<Int>>;
}

export interface CompanySubscriptionPayload {
  mutation: MutationType;
  node: Company;
  updatedFields: String[];
  previousValues: CompanyPreviousValues;
}

export interface CompanySubscriptionPayloadPromise
  extends Promise<CompanySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CompanyPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CompanyPreviousValuesPromise>() => T;
}

export interface CompanySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CompanySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CompanySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CompanyPreviousValuesSubscription>() => T;
}

export interface CompanyPreviousValues {
  id: ID_Output;
  name?: String;
  type?: CompanyType;
  emailDomains: String[];
  stripeCustomerId?: String;
}

export interface CompanyPreviousValuesPromise
  extends Promise<CompanyPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  type: () => Promise<CompanyType>;
  emailDomains: () => Promise<String[]>;
  stripeCustomerId: () => Promise<String>;
}

export interface CompanyPreviousValuesSubscription
  extends Promise<AsyncIterator<CompanyPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<CompanyType>>;
  emailDomains: () => Promise<AsyncIterator<String[]>>;
  stripeCustomerId: () => Promise<AsyncIterator<String>>;
}

export interface PhotoSubscriptionPayload {
  mutation: MutationType;
  node: Photo;
  updatedFields: String[];
  previousValues: PhotoPreviousValues;
}

export interface PhotoSubscriptionPayloadPromise
  extends Promise<PhotoSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PhotoPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PhotoPreviousValuesPromise>() => T;
}

export interface PhotoSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PhotoSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PhotoSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PhotoPreviousValuesSubscription>() => T;
}

export interface PhotoPreviousValues {
  id: ID_Output;
  url: String;
}

export interface PhotoPreviousValuesPromise
  extends Promise<PhotoPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  url: () => Promise<String>;
}

export interface PhotoPreviousValuesSubscription
  extends Promise<AsyncIterator<PhotoPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  url: () => Promise<AsyncIterator<String>>;
}

export interface PlaceSubscriptionPayload {
  mutation: MutationType;
  node: Place;
  updatedFields: String[];
  previousValues: PlacePreviousValues;
}

export interface PlaceSubscriptionPayloadPromise
  extends Promise<PlaceSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PlacePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PlacePreviousValuesPromise>() => T;
}

export interface PlaceSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PlaceSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PlaceSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PlacePreviousValuesSubscription>() => T;
}

export interface PlacePreviousValues {
  id: ID_Output;
  name: String;
  category: Category;
  headline?: String;
  description?: String;
}

export interface PlacePreviousValuesPromise
  extends Promise<PlacePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  category: () => Promise<Category>;
  headline: () => Promise<String>;
  description: () => Promise<String>;
}

export interface PlacePreviousValuesSubscription
  extends Promise<AsyncIterator<PlacePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  category: () => Promise<AsyncIterator<Category>>;
  headline: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
}

export interface QuizSubscriptionPayload {
  mutation: MutationType;
  node: Quiz;
  updatedFields: String[];
  previousValues: QuizPreviousValues;
}

export interface QuizSubscriptionPayloadPromise
  extends Promise<QuizSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = QuizPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = QuizPreviousValuesPromise>() => T;
}

export interface QuizSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<QuizSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = QuizSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = QuizPreviousValuesSubscription>() => T;
}

export interface QuizPreviousValues {
  id: ID_Output;
  name: String;
  question: String;
  choices: String[];
  answer: String;
  value: Int;
}

export interface QuizPreviousValuesPromise
  extends Promise<QuizPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  question: () => Promise<String>;
  choices: () => Promise<String[]>;
  answer: () => Promise<String>;
  value: () => Promise<Int>;
}

export interface QuizPreviousValuesSubscription
  extends Promise<AsyncIterator<QuizPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  question: () => Promise<AsyncIterator<String>>;
  choices: () => Promise<AsyncIterator<String[]>>;
  answer: () => Promise<AsyncIterator<String>>;
  value: () => Promise<AsyncIterator<Int>>;
}

export interface TagSubscriptionPayload {
  mutation: MutationType;
  node: Tag;
  updatedFields: String[];
  previousValues: TagPreviousValues;
}

export interface TagSubscriptionPayloadPromise
  extends Promise<TagSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TagPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TagPreviousValuesPromise>() => T;
}

export interface TagSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TagSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TagSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TagPreviousValuesSubscription>() => T;
}

export interface TagPreviousValues {
  id: ID_Output;
  label: String;
  root?: Boolean;
  leaf?: Boolean;
  category: Category;
}

export interface TagPreviousValuesPromise
  extends Promise<TagPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  label: () => Promise<String>;
  root: () => Promise<Boolean>;
  leaf: () => Promise<Boolean>;
  category: () => Promise<Category>;
}

export interface TagPreviousValuesSubscription
  extends Promise<AsyncIterator<TagPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  label: () => Promise<AsyncIterator<String>>;
  root: () => Promise<AsyncIterator<Boolean>>;
  leaf: () => Promise<AsyncIterator<Boolean>>;
  category: () => Promise<AsyncIterator<Category>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface UserPreviousValues {
  id: ID_Output;
  firstName?: String;
  lastName?: String;
  email?: String;
  phone?: String;
  password?: String;
  role?: Role;
  isRepresentative?: Boolean;
  points?: Int;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  email: () => Promise<String>;
  phone: () => Promise<String>;
  password: () => Promise<String>;
  role: () => Promise<Role>;
  isRepresentative: () => Promise<Boolean>;
  points: () => Promise<Int>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  role: () => Promise<AsyncIterator<Role>>;
  isRepresentative: () => Promise<AsyncIterator<Boolean>>;
  points: () => Promise<AsyncIterator<Int>>;
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "User",
    embedded: false
  },
  {
    name: "Place",
    embedded: false
  },
  {
    name: "Company",
    embedded: false
  },
  {
    name: "Tag",
    embedded: false
  },
  {
    name: "Photo",
    embedded: false
  },
  {
    name: "Address",
    embedded: true
  },
  {
    name: "Hour",
    embedded: true
  },
  {
    name: "Social",
    embedded: true
  },
  {
    name: "Quiz",
    embedded: false
  },
  {
    name: "Challenge",
    embedded: false
  },
  {
    name: "CompanyType",
    embedded: false
  },
  {
    name: "Day",
    embedded: false
  },
  {
    name: "Category",
    embedded: false
  },
  {
    name: "Role",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
