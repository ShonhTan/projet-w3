// Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  article: (where?: ArticleWhereInput) => Promise<boolean>;
  challenge: (where?: ChallengeWhereInput) => Promise<boolean>;
  company: (where?: CompanyWhereInput) => Promise<boolean>;
  photo: (where?: PhotoWhereInput) => Promise<boolean>;
  place: (where?: PlaceWhereInput) => Promise<boolean>;
  tag: (where?: TagWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
  validatedQuiz: (where?: ValidatedQuizWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  article: (where: ArticleWhereUniqueInput) => ArticleNullablePromise;
  articles: (args?: {
    where?: ArticleWhereInput;
    orderBy?: ArticleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Article>;
  articlesConnection: (args?: {
    where?: ArticleWhereInput;
    orderBy?: ArticleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ArticleConnectionPromise;
  challenge: (where: ChallengeWhereUniqueInput) => ChallengeNullablePromise;
  challenges: (args?: {
    where?: ChallengeWhereInput;
    orderBy?: ChallengeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Challenge>;
  challengesConnection: (args?: {
    where?: ChallengeWhereInput;
    orderBy?: ChallengeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ChallengeConnectionPromise;
  company: (where: CompanyWhereUniqueInput) => CompanyNullablePromise;
  companies: (args?: {
    where?: CompanyWhereInput;
    orderBy?: CompanyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Company>;
  companiesConnection: (args?: {
    where?: CompanyWhereInput;
    orderBy?: CompanyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CompanyConnectionPromise;
  photo: (where: PhotoWhereUniqueInput) => PhotoNullablePromise;
  photos: (args?: {
    where?: PhotoWhereInput;
    orderBy?: PhotoOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Photo>;
  photosConnection: (args?: {
    where?: PhotoWhereInput;
    orderBy?: PhotoOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PhotoConnectionPromise;
  place: (where: PlaceWhereUniqueInput) => PlaceNullablePromise;
  places: (args?: {
    where?: PlaceWhereInput;
    orderBy?: PlaceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Place>;
  placesConnection: (args?: {
    where?: PlaceWhereInput;
    orderBy?: PlaceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PlaceConnectionPromise;
  tag: (where: TagWhereUniqueInput) => TagNullablePromise;
  tags: (args?: {
    where?: TagWhereInput;
    orderBy?: TagOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Tag>;
  tagsConnection: (args?: {
    where?: TagWhereInput;
    orderBy?: TagOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => TagConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserNullablePromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  validatedQuiz: (
    where: ValidatedQuizWhereUniqueInput
  ) => ValidatedQuizNullablePromise;
  validatedQuizzes: (args?: {
    where?: ValidatedQuizWhereInput;
    orderBy?: ValidatedQuizOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ValidatedQuiz>;
  validatedQuizzesConnection: (args?: {
    where?: ValidatedQuizWhereInput;
    orderBy?: ValidatedQuizOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ValidatedQuizConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createArticle: (data: ArticleCreateInput) => ArticlePromise;
  updateArticle: (args: {
    data: ArticleUpdateInput;
    where: ArticleWhereUniqueInput;
  }) => ArticlePromise;
  updateManyArticles: (args: {
    data: ArticleUpdateManyMutationInput;
    where?: ArticleWhereInput;
  }) => BatchPayloadPromise;
  upsertArticle: (args: {
    where: ArticleWhereUniqueInput;
    create: ArticleCreateInput;
    update: ArticleUpdateInput;
  }) => ArticlePromise;
  deleteArticle: (where: ArticleWhereUniqueInput) => ArticlePromise;
  deleteManyArticles: (where?: ArticleWhereInput) => BatchPayloadPromise;
  createChallenge: (data: ChallengeCreateInput) => ChallengePromise;
  updateChallenge: (args: {
    data: ChallengeUpdateInput;
    where: ChallengeWhereUniqueInput;
  }) => ChallengePromise;
  updateManyChallenges: (args: {
    data: ChallengeUpdateManyMutationInput;
    where?: ChallengeWhereInput;
  }) => BatchPayloadPromise;
  upsertChallenge: (args: {
    where: ChallengeWhereUniqueInput;
    create: ChallengeCreateInput;
    update: ChallengeUpdateInput;
  }) => ChallengePromise;
  deleteChallenge: (where: ChallengeWhereUniqueInput) => ChallengePromise;
  deleteManyChallenges: (where?: ChallengeWhereInput) => BatchPayloadPromise;
  createCompany: (data: CompanyCreateInput) => CompanyPromise;
  updateCompany: (args: {
    data: CompanyUpdateInput;
    where: CompanyWhereUniqueInput;
  }) => CompanyPromise;
  updateManyCompanies: (args: {
    data: CompanyUpdateManyMutationInput;
    where?: CompanyWhereInput;
  }) => BatchPayloadPromise;
  upsertCompany: (args: {
    where: CompanyWhereUniqueInput;
    create: CompanyCreateInput;
    update: CompanyUpdateInput;
  }) => CompanyPromise;
  deleteCompany: (where: CompanyWhereUniqueInput) => CompanyPromise;
  deleteManyCompanies: (where?: CompanyWhereInput) => BatchPayloadPromise;
  createPhoto: (data: PhotoCreateInput) => PhotoPromise;
  updatePhoto: (args: {
    data: PhotoUpdateInput;
    where: PhotoWhereUniqueInput;
  }) => PhotoPromise;
  updateManyPhotos: (args: {
    data: PhotoUpdateManyMutationInput;
    where?: PhotoWhereInput;
  }) => BatchPayloadPromise;
  upsertPhoto: (args: {
    where: PhotoWhereUniqueInput;
    create: PhotoCreateInput;
    update: PhotoUpdateInput;
  }) => PhotoPromise;
  deletePhoto: (where: PhotoWhereUniqueInput) => PhotoPromise;
  deleteManyPhotos: (where?: PhotoWhereInput) => BatchPayloadPromise;
  createPlace: (data: PlaceCreateInput) => PlacePromise;
  updatePlace: (args: {
    data: PlaceUpdateInput;
    where: PlaceWhereUniqueInput;
  }) => PlacePromise;
  updateManyPlaces: (args: {
    data: PlaceUpdateManyMutationInput;
    where?: PlaceWhereInput;
  }) => BatchPayloadPromise;
  upsertPlace: (args: {
    where: PlaceWhereUniqueInput;
    create: PlaceCreateInput;
    update: PlaceUpdateInput;
  }) => PlacePromise;
  deletePlace: (where: PlaceWhereUniqueInput) => PlacePromise;
  deleteManyPlaces: (where?: PlaceWhereInput) => BatchPayloadPromise;
  createTag: (data: TagCreateInput) => TagPromise;
  updateTag: (args: {
    data: TagUpdateInput;
    where: TagWhereUniqueInput;
  }) => TagPromise;
  updateManyTags: (args: {
    data: TagUpdateManyMutationInput;
    where?: TagWhereInput;
  }) => BatchPayloadPromise;
  upsertTag: (args: {
    where: TagWhereUniqueInput;
    create: TagCreateInput;
    update: TagUpdateInput;
  }) => TagPromise;
  deleteTag: (where: TagWhereUniqueInput) => TagPromise;
  deleteManyTags: (where?: TagWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;
  createValidatedQuiz: (data: ValidatedQuizCreateInput) => ValidatedQuizPromise;
  updateValidatedQuiz: (args: {
    data: ValidatedQuizUpdateInput;
    where: ValidatedQuizWhereUniqueInput;
  }) => ValidatedQuizPromise;
  updateManyValidatedQuizzes: (args: {
    data: ValidatedQuizUpdateManyMutationInput;
    where?: ValidatedQuizWhereInput;
  }) => BatchPayloadPromise;
  upsertValidatedQuiz: (args: {
    where: ValidatedQuizWhereUniqueInput;
    create: ValidatedQuizCreateInput;
    update: ValidatedQuizUpdateInput;
  }) => ValidatedQuizPromise;
  deleteValidatedQuiz: (
    where: ValidatedQuizWhereUniqueInput
  ) => ValidatedQuizPromise;
  deleteManyValidatedQuizzes: (
    where?: ValidatedQuizWhereInput
  ) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  article: (
    where?: ArticleSubscriptionWhereInput
  ) => ArticleSubscriptionPayloadSubscription;
  challenge: (
    where?: ChallengeSubscriptionWhereInput
  ) => ChallengeSubscriptionPayloadSubscription;
  company: (
    where?: CompanySubscriptionWhereInput
  ) => CompanySubscriptionPayloadSubscription;
  photo: (
    where?: PhotoSubscriptionWhereInput
  ) => PhotoSubscriptionPayloadSubscription;
  place: (
    where?: PlaceSubscriptionWhereInput
  ) => PlaceSubscriptionPayloadSubscription;
  tag: (
    where?: TagSubscriptionWhereInput
  ) => TagSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
  validatedQuiz: (
    where?: ValidatedQuizSubscriptionWhereInput
  ) => ValidatedQuizSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type ArticleOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "content_ASC"
  | "content_DESC"
  | "picture_ASC"
  | "picture_DESC"
  | "video_ASC"
  | "video_DESC"
  | "date_ASC"
  | "date_DESC";

export type ChallengeCategory =
  | "HEALTHY"
  | "SUPER_HEALTHY"
  | "HYPER_HEALTHY"
  | "MEGA_HEALTHY"
  | "ULTRA_HEALTHY"
  | "MAXI_HEALTHY"
  | "EX_HEALTHY";

export type CompanyType = "COMPANY" | "SCHOOL" | "PLACE" | "COWORKING";

export type Role = "SUPER_ADMIN" | "ADMIN" | "MODERATOR" | "USER" | "PLACE";

export type CompanyOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "type_ASC"
  | "type_DESC"
  | "stripeCustomerId_ASC"
  | "stripeCustomerId_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "firstName_ASC"
  | "firstName_DESC"
  | "lastName_ASC"
  | "lastName_DESC"
  | "email_ASC"
  | "email_DESC"
  | "phone_ASC"
  | "phone_DESC"
  | "password_ASC"
  | "password_DESC"
  | "role_ASC"
  | "role_DESC"
  | "isRepresentative_ASC"
  | "isRepresentative_DESC"
  | "points_ASC"
  | "points_DESC";

export type ChallengeOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "description_ASC"
  | "description_DESC"
  | "category_ASC"
  | "category_DESC"
  | "value_ASC"
  | "value_DESC";

export type ValidatedQuizOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "status_ASC"
  | "status_DESC";

export type PhotoOrderByInput = "id_ASC" | "id_DESC" | "uri_ASC" | "uri_DESC";

export type Category = "FOOD" | "SHOP" | "ACTIVITY";

export type Day =
  | "MONDAY"
  | "TUESDAY"
  | "WEDNESDAY"
  | "THURSDAY"
  | "FRIDAY"
  | "SATURDAY"
  | "SUNDAY";

export type TagOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "label_ASC"
  | "label_DESC"
  | "root_ASC"
  | "root_DESC"
  | "leaf_ASC"
  | "leaf_DESC"
  | "category_ASC"
  | "category_DESC";

export type PlaceOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "category_ASC"
  | "category_DESC"
  | "headline_ASC"
  | "headline_DESC"
  | "description_ASC"
  | "description_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type ArticleWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ArticleWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  content?: Maybe<String>;
  content_not?: Maybe<String>;
  content_in?: Maybe<String[] | String>;
  content_not_in?: Maybe<String[] | String>;
  content_lt?: Maybe<String>;
  content_lte?: Maybe<String>;
  content_gt?: Maybe<String>;
  content_gte?: Maybe<String>;
  content_contains?: Maybe<String>;
  content_not_contains?: Maybe<String>;
  content_starts_with?: Maybe<String>;
  content_not_starts_with?: Maybe<String>;
  content_ends_with?: Maybe<String>;
  content_not_ends_with?: Maybe<String>;
  picture?: Maybe<String>;
  picture_not?: Maybe<String>;
  picture_in?: Maybe<String[] | String>;
  picture_not_in?: Maybe<String[] | String>;
  picture_lt?: Maybe<String>;
  picture_lte?: Maybe<String>;
  picture_gt?: Maybe<String>;
  picture_gte?: Maybe<String>;
  picture_contains?: Maybe<String>;
  picture_not_contains?: Maybe<String>;
  picture_starts_with?: Maybe<String>;
  picture_not_starts_with?: Maybe<String>;
  picture_ends_with?: Maybe<String>;
  picture_not_ends_with?: Maybe<String>;
  video?: Maybe<String>;
  video_not?: Maybe<String>;
  video_in?: Maybe<String[] | String>;
  video_not_in?: Maybe<String[] | String>;
  video_lt?: Maybe<String>;
  video_lte?: Maybe<String>;
  video_gt?: Maybe<String>;
  video_gte?: Maybe<String>;
  video_contains?: Maybe<String>;
  video_not_contains?: Maybe<String>;
  video_starts_with?: Maybe<String>;
  video_not_starts_with?: Maybe<String>;
  video_ends_with?: Maybe<String>;
  video_not_ends_with?: Maybe<String>;
  quiz?: Maybe<QuizWhereInput>;
  date?: Maybe<String>;
  date_not?: Maybe<String>;
  date_in?: Maybe<String[] | String>;
  date_not_in?: Maybe<String[] | String>;
  date_lt?: Maybe<String>;
  date_lte?: Maybe<String>;
  date_gt?: Maybe<String>;
  date_gte?: Maybe<String>;
  date_contains?: Maybe<String>;
  date_not_contains?: Maybe<String>;
  date_starts_with?: Maybe<String>;
  date_not_starts_with?: Maybe<String>;
  date_ends_with?: Maybe<String>;
  date_not_ends_with?: Maybe<String>;
  AND?: Maybe<ArticleWhereInput[] | ArticleWhereInput>;
}

export interface QuizWhereInput {
  question?: Maybe<String>;
  question_not?: Maybe<String>;
  question_in?: Maybe<String[] | String>;
  question_not_in?: Maybe<String[] | String>;
  question_lt?: Maybe<String>;
  question_lte?: Maybe<String>;
  question_gt?: Maybe<String>;
  question_gte?: Maybe<String>;
  question_contains?: Maybe<String>;
  question_not_contains?: Maybe<String>;
  question_starts_with?: Maybe<String>;
  question_not_starts_with?: Maybe<String>;
  question_ends_with?: Maybe<String>;
  question_not_ends_with?: Maybe<String>;
  answer?: Maybe<String>;
  answer_not?: Maybe<String>;
  answer_in?: Maybe<String[] | String>;
  answer_not_in?: Maybe<String[] | String>;
  answer_lt?: Maybe<String>;
  answer_lte?: Maybe<String>;
  answer_gt?: Maybe<String>;
  answer_gte?: Maybe<String>;
  answer_contains?: Maybe<String>;
  answer_not_contains?: Maybe<String>;
  answer_starts_with?: Maybe<String>;
  answer_not_starts_with?: Maybe<String>;
  answer_ends_with?: Maybe<String>;
  answer_not_ends_with?: Maybe<String>;
  value?: Maybe<Int>;
  value_not?: Maybe<Int>;
  value_in?: Maybe<Int[] | Int>;
  value_not_in?: Maybe<Int[] | Int>;
  value_lt?: Maybe<Int>;
  value_lte?: Maybe<Int>;
  value_gt?: Maybe<Int>;
  value_gte?: Maybe<Int>;
  AND?: Maybe<QuizWhereInput[] | QuizWhereInput>;
}

export type ChallengeWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface CompanyWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  type?: Maybe<CompanyType>;
  type_not?: Maybe<CompanyType>;
  type_in?: Maybe<CompanyType[] | CompanyType>;
  type_not_in?: Maybe<CompanyType[] | CompanyType>;
  address?: Maybe<AddressWhereInput>;
  users_some?: Maybe<UserWhereInput>;
  stripeCustomerId?: Maybe<String>;
  stripeCustomerId_not?: Maybe<String>;
  stripeCustomerId_in?: Maybe<String[] | String>;
  stripeCustomerId_not_in?: Maybe<String[] | String>;
  stripeCustomerId_lt?: Maybe<String>;
  stripeCustomerId_lte?: Maybe<String>;
  stripeCustomerId_gt?: Maybe<String>;
  stripeCustomerId_gte?: Maybe<String>;
  stripeCustomerId_contains?: Maybe<String>;
  stripeCustomerId_not_contains?: Maybe<String>;
  stripeCustomerId_starts_with?: Maybe<String>;
  stripeCustomerId_not_starts_with?: Maybe<String>;
  stripeCustomerId_ends_with?: Maybe<String>;
  stripeCustomerId_not_ends_with?: Maybe<String>;
  challenges_some?: Maybe<ChallengeWhereInput>;
  AND?: Maybe<CompanyWhereInput[] | CompanyWhereInput>;
}

export interface AddressWhereInput {
  street?: Maybe<String>;
  street_not?: Maybe<String>;
  street_in?: Maybe<String[] | String>;
  street_not_in?: Maybe<String[] | String>;
  street_lt?: Maybe<String>;
  street_lte?: Maybe<String>;
  street_gt?: Maybe<String>;
  street_gte?: Maybe<String>;
  street_contains?: Maybe<String>;
  street_not_contains?: Maybe<String>;
  street_starts_with?: Maybe<String>;
  street_not_starts_with?: Maybe<String>;
  street_ends_with?: Maybe<String>;
  street_not_ends_with?: Maybe<String>;
  zipCode?: Maybe<String>;
  zipCode_not?: Maybe<String>;
  zipCode_in?: Maybe<String[] | String>;
  zipCode_not_in?: Maybe<String[] | String>;
  zipCode_lt?: Maybe<String>;
  zipCode_lte?: Maybe<String>;
  zipCode_gt?: Maybe<String>;
  zipCode_gte?: Maybe<String>;
  zipCode_contains?: Maybe<String>;
  zipCode_not_contains?: Maybe<String>;
  zipCode_starts_with?: Maybe<String>;
  zipCode_not_starts_with?: Maybe<String>;
  zipCode_ends_with?: Maybe<String>;
  zipCode_not_ends_with?: Maybe<String>;
  city?: Maybe<String>;
  city_not?: Maybe<String>;
  city_in?: Maybe<String[] | String>;
  city_not_in?: Maybe<String[] | String>;
  city_lt?: Maybe<String>;
  city_lte?: Maybe<String>;
  city_gt?: Maybe<String>;
  city_gte?: Maybe<String>;
  city_contains?: Maybe<String>;
  city_not_contains?: Maybe<String>;
  city_starts_with?: Maybe<String>;
  city_not_starts_with?: Maybe<String>;
  city_ends_with?: Maybe<String>;
  city_not_ends_with?: Maybe<String>;
  location?: Maybe<PointWhereInput>;
  AND?: Maybe<AddressWhereInput[] | AddressWhereInput>;
}

export interface PointWhereInput {
  type?: Maybe<String>;
  type_not?: Maybe<String>;
  type_in?: Maybe<String[] | String>;
  type_not_in?: Maybe<String[] | String>;
  type_lt?: Maybe<String>;
  type_lte?: Maybe<String>;
  type_gt?: Maybe<String>;
  type_gte?: Maybe<String>;
  type_contains?: Maybe<String>;
  type_not_contains?: Maybe<String>;
  type_starts_with?: Maybe<String>;
  type_not_starts_with?: Maybe<String>;
  type_ends_with?: Maybe<String>;
  type_not_ends_with?: Maybe<String>;
  AND?: Maybe<PointWhereInput[] | PointWhereInput>;
}

export interface UserWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  firstName?: Maybe<String>;
  firstName_not?: Maybe<String>;
  firstName_in?: Maybe<String[] | String>;
  firstName_not_in?: Maybe<String[] | String>;
  firstName_lt?: Maybe<String>;
  firstName_lte?: Maybe<String>;
  firstName_gt?: Maybe<String>;
  firstName_gte?: Maybe<String>;
  firstName_contains?: Maybe<String>;
  firstName_not_contains?: Maybe<String>;
  firstName_starts_with?: Maybe<String>;
  firstName_not_starts_with?: Maybe<String>;
  firstName_ends_with?: Maybe<String>;
  firstName_not_ends_with?: Maybe<String>;
  lastName?: Maybe<String>;
  lastName_not?: Maybe<String>;
  lastName_in?: Maybe<String[] | String>;
  lastName_not_in?: Maybe<String[] | String>;
  lastName_lt?: Maybe<String>;
  lastName_lte?: Maybe<String>;
  lastName_gt?: Maybe<String>;
  lastName_gte?: Maybe<String>;
  lastName_contains?: Maybe<String>;
  lastName_not_contains?: Maybe<String>;
  lastName_starts_with?: Maybe<String>;
  lastName_not_starts_with?: Maybe<String>;
  lastName_ends_with?: Maybe<String>;
  lastName_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  phone?: Maybe<String>;
  phone_not?: Maybe<String>;
  phone_in?: Maybe<String[] | String>;
  phone_not_in?: Maybe<String[] | String>;
  phone_lt?: Maybe<String>;
  phone_lte?: Maybe<String>;
  phone_gt?: Maybe<String>;
  phone_gte?: Maybe<String>;
  phone_contains?: Maybe<String>;
  phone_not_contains?: Maybe<String>;
  phone_starts_with?: Maybe<String>;
  phone_not_starts_with?: Maybe<String>;
  phone_ends_with?: Maybe<String>;
  phone_not_ends_with?: Maybe<String>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  role?: Maybe<Role>;
  role_not?: Maybe<Role>;
  role_in?: Maybe<Role[] | Role>;
  role_not_in?: Maybe<Role[] | Role>;
  isRepresentative?: Maybe<Boolean>;
  isRepresentative_not?: Maybe<Boolean>;
  company?: Maybe<CompanyWhereInput>;
  points?: Maybe<Int>;
  points_not?: Maybe<Int>;
  points_in?: Maybe<Int[] | Int>;
  points_not_in?: Maybe<Int[] | Int>;
  points_lt?: Maybe<Int>;
  points_lte?: Maybe<Int>;
  points_gt?: Maybe<Int>;
  points_gte?: Maybe<Int>;
  validatedChallenges_some?: Maybe<ChallengeWhereInput>;
  validatedQuizzes_some?: Maybe<ValidatedQuizWhereInput>;
  AND?: Maybe<UserWhereInput[] | UserWhereInput>;
}

export interface ChallengeWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  category?: Maybe<ChallengeCategory>;
  category_not?: Maybe<ChallengeCategory>;
  category_in?: Maybe<ChallengeCategory[] | ChallengeCategory>;
  category_not_in?: Maybe<ChallengeCategory[] | ChallengeCategory>;
  value?: Maybe<Int>;
  value_not?: Maybe<Int>;
  value_in?: Maybe<Int[] | Int>;
  value_not_in?: Maybe<Int[] | Int>;
  value_lt?: Maybe<Int>;
  value_lte?: Maybe<Int>;
  value_gt?: Maybe<Int>;
  value_gte?: Maybe<Int>;
  companies_some?: Maybe<CompanyWhereInput>;
  AND?: Maybe<ChallengeWhereInput[] | ChallengeWhereInput>;
}

export interface ValidatedQuizWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  article?: Maybe<ArticleWhereInput>;
  status?: Maybe<Boolean>;
  status_not?: Maybe<Boolean>;
  AND?: Maybe<ValidatedQuizWhereInput[] | ValidatedQuizWhereInput>;
}

export type CompanyWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type PhotoWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  uri?: Maybe<String>;
}>;

export interface PhotoWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  uri?: Maybe<String>;
  uri_not?: Maybe<String>;
  uri_in?: Maybe<String[] | String>;
  uri_not_in?: Maybe<String[] | String>;
  uri_lt?: Maybe<String>;
  uri_lte?: Maybe<String>;
  uri_gt?: Maybe<String>;
  uri_gte?: Maybe<String>;
  uri_contains?: Maybe<String>;
  uri_not_contains?: Maybe<String>;
  uri_starts_with?: Maybe<String>;
  uri_not_starts_with?: Maybe<String>;
  uri_ends_with?: Maybe<String>;
  uri_not_ends_with?: Maybe<String>;
  AND?: Maybe<PhotoWhereInput[] | PhotoWhereInput>;
}

export type PlaceWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  name?: Maybe<String>;
}>;

export interface TagWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  label?: Maybe<String>;
  label_not?: Maybe<String>;
  label_in?: Maybe<String[] | String>;
  label_not_in?: Maybe<String[] | String>;
  label_lt?: Maybe<String>;
  label_lte?: Maybe<String>;
  label_gt?: Maybe<String>;
  label_gte?: Maybe<String>;
  label_contains?: Maybe<String>;
  label_not_contains?: Maybe<String>;
  label_starts_with?: Maybe<String>;
  label_not_starts_with?: Maybe<String>;
  label_ends_with?: Maybe<String>;
  label_not_ends_with?: Maybe<String>;
  children_some?: Maybe<TagWhereInput>;
  root?: Maybe<Boolean>;
  root_not?: Maybe<Boolean>;
  leaf?: Maybe<Boolean>;
  leaf_not?: Maybe<Boolean>;
  category?: Maybe<Category>;
  category_not?: Maybe<Category>;
  category_in?: Maybe<Category[] | Category>;
  category_not_in?: Maybe<Category[] | Category>;
  AND?: Maybe<TagWhereInput[] | TagWhereInput>;
}

export interface PlaceWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  category?: Maybe<Category>;
  category_not?: Maybe<Category>;
  category_in?: Maybe<Category[] | Category>;
  category_not_in?: Maybe<Category[] | Category>;
  address?: Maybe<AddressWhereInput>;
  user?: Maybe<UserWhereInput>;
  social?: Maybe<SocialWhereInput>;
  headline?: Maybe<String>;
  headline_not?: Maybe<String>;
  headline_in?: Maybe<String[] | String>;
  headline_not_in?: Maybe<String[] | String>;
  headline_lt?: Maybe<String>;
  headline_lte?: Maybe<String>;
  headline_gt?: Maybe<String>;
  headline_gte?: Maybe<String>;
  headline_contains?: Maybe<String>;
  headline_not_contains?: Maybe<String>;
  headline_starts_with?: Maybe<String>;
  headline_not_starts_with?: Maybe<String>;
  headline_ends_with?: Maybe<String>;
  headline_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  hours_some?: Maybe<HourWhereInput>;
  hours_every?: Maybe<HourRestrictedWhereInput>;
  hours_none?: Maybe<HourRestrictedWhereInput>;
  tags_some?: Maybe<TagWhereInput>;
  photos_some?: Maybe<PhotoWhereInput>;
  AND?: Maybe<PlaceWhereInput[] | PlaceWhereInput>;
}

export interface SocialWhereInput {
  website?: Maybe<String>;
  website_not?: Maybe<String>;
  website_in?: Maybe<String[] | String>;
  website_not_in?: Maybe<String[] | String>;
  website_lt?: Maybe<String>;
  website_lte?: Maybe<String>;
  website_gt?: Maybe<String>;
  website_gte?: Maybe<String>;
  website_contains?: Maybe<String>;
  website_not_contains?: Maybe<String>;
  website_starts_with?: Maybe<String>;
  website_not_starts_with?: Maybe<String>;
  website_ends_with?: Maybe<String>;
  website_not_ends_with?: Maybe<String>;
  facebook?: Maybe<String>;
  facebook_not?: Maybe<String>;
  facebook_in?: Maybe<String[] | String>;
  facebook_not_in?: Maybe<String[] | String>;
  facebook_lt?: Maybe<String>;
  facebook_lte?: Maybe<String>;
  facebook_gt?: Maybe<String>;
  facebook_gte?: Maybe<String>;
  facebook_contains?: Maybe<String>;
  facebook_not_contains?: Maybe<String>;
  facebook_starts_with?: Maybe<String>;
  facebook_not_starts_with?: Maybe<String>;
  facebook_ends_with?: Maybe<String>;
  facebook_not_ends_with?: Maybe<String>;
  instagram?: Maybe<String>;
  instagram_not?: Maybe<String>;
  instagram_in?: Maybe<String[] | String>;
  instagram_not_in?: Maybe<String[] | String>;
  instagram_lt?: Maybe<String>;
  instagram_lte?: Maybe<String>;
  instagram_gt?: Maybe<String>;
  instagram_gte?: Maybe<String>;
  instagram_contains?: Maybe<String>;
  instagram_not_contains?: Maybe<String>;
  instagram_starts_with?: Maybe<String>;
  instagram_not_starts_with?: Maybe<String>;
  instagram_ends_with?: Maybe<String>;
  instagram_not_ends_with?: Maybe<String>;
  AND?: Maybe<SocialWhereInput[] | SocialWhereInput>;
}

export interface HourWhereInput {
  day?: Maybe<Day>;
  day_not?: Maybe<Day>;
  day_in?: Maybe<Day[] | Day>;
  day_not_in?: Maybe<Day[] | Day>;
  start?: Maybe<String>;
  start_not?: Maybe<String>;
  start_in?: Maybe<String[] | String>;
  start_not_in?: Maybe<String[] | String>;
  start_lt?: Maybe<String>;
  start_lte?: Maybe<String>;
  start_gt?: Maybe<String>;
  start_gte?: Maybe<String>;
  start_contains?: Maybe<String>;
  start_not_contains?: Maybe<String>;
  start_starts_with?: Maybe<String>;
  start_not_starts_with?: Maybe<String>;
  start_ends_with?: Maybe<String>;
  start_not_ends_with?: Maybe<String>;
  end?: Maybe<String>;
  end_not?: Maybe<String>;
  end_in?: Maybe<String[] | String>;
  end_not_in?: Maybe<String[] | String>;
  end_lt?: Maybe<String>;
  end_lte?: Maybe<String>;
  end_gt?: Maybe<String>;
  end_gte?: Maybe<String>;
  end_contains?: Maybe<String>;
  end_not_contains?: Maybe<String>;
  end_starts_with?: Maybe<String>;
  end_not_starts_with?: Maybe<String>;
  end_ends_with?: Maybe<String>;
  end_not_ends_with?: Maybe<String>;
  AND?: Maybe<HourWhereInput[] | HourWhereInput>;
}

export interface HourRestrictedWhereInput {
  day?: Maybe<Day>;
  day_not?: Maybe<Day>;
  day_in?: Maybe<Day[] | Day>;
  day_not_in?: Maybe<Day[] | Day>;
  start?: Maybe<String>;
  start_not?: Maybe<String>;
  start_in?: Maybe<String[] | String>;
  start_not_in?: Maybe<String[] | String>;
  start_lt?: Maybe<String>;
  start_lte?: Maybe<String>;
  start_gt?: Maybe<String>;
  start_gte?: Maybe<String>;
  start_contains?: Maybe<String>;
  start_not_contains?: Maybe<String>;
  start_starts_with?: Maybe<String>;
  start_not_starts_with?: Maybe<String>;
  start_ends_with?: Maybe<String>;
  start_not_ends_with?: Maybe<String>;
  end?: Maybe<String>;
  end_not?: Maybe<String>;
  end_in?: Maybe<String[] | String>;
  end_not_in?: Maybe<String[] | String>;
  end_lt?: Maybe<String>;
  end_lte?: Maybe<String>;
  end_gt?: Maybe<String>;
  end_gte?: Maybe<String>;
  end_contains?: Maybe<String>;
  end_not_contains?: Maybe<String>;
  end_starts_with?: Maybe<String>;
  end_not_starts_with?: Maybe<String>;
  end_ends_with?: Maybe<String>;
  end_not_ends_with?: Maybe<String>;
  AND?: Maybe<HourRestrictedWhereInput[] | HourRestrictedWhereInput>;
}

export type TagWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type UserWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  email?: Maybe<String>;
}>;

export type ValidatedQuizWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ArticleCreateInput {
  id?: Maybe<ID_Input>;
  title: String;
  content: String;
  picture?: Maybe<String>;
  video?: Maybe<String>;
  quiz?: Maybe<QuizCreateOneInput>;
  date: String;
}

export interface QuizCreateOneInput {
  create?: Maybe<QuizCreateInput>;
}

export interface QuizCreateInput {
  question: String;
  choices?: Maybe<QuizCreatechoicesInput>;
  answer: String;
  value: Int;
}

export interface QuizCreatechoicesInput {
  set?: Maybe<String[] | String>;
}

export interface ArticleUpdateInput {
  title?: Maybe<String>;
  content?: Maybe<String>;
  picture?: Maybe<String>;
  video?: Maybe<String>;
  quiz?: Maybe<QuizUpdateOneInput>;
  date?: Maybe<String>;
}

export interface QuizUpdateOneInput {
  create?: Maybe<QuizCreateInput>;
  update?: Maybe<QuizUpdateDataInput>;
  upsert?: Maybe<QuizUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
}

export interface QuizUpdateDataInput {
  question?: Maybe<String>;
  choices?: Maybe<QuizUpdatechoicesInput>;
  answer?: Maybe<String>;
  value?: Maybe<Int>;
}

export interface QuizUpdatechoicesInput {
  set?: Maybe<String[] | String>;
}

export interface QuizUpsertNestedInput {
  update: QuizUpdateDataInput;
  create: QuizCreateInput;
}

export interface ArticleUpdateManyMutationInput {
  title?: Maybe<String>;
  content?: Maybe<String>;
  picture?: Maybe<String>;
  video?: Maybe<String>;
  date?: Maybe<String>;
}

export interface ChallengeCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  description: String;
  category?: Maybe<ChallengeCategory>;
  value: Int;
  companies?: Maybe<CompanyCreateManyWithoutChallengesInput>;
}

export interface CompanyCreateManyWithoutChallengesInput {
  create?: Maybe<
    CompanyCreateWithoutChallengesInput[] | CompanyCreateWithoutChallengesInput
  >;
  connect?: Maybe<CompanyWhereUniqueInput[] | CompanyWhereUniqueInput>;
}

export interface CompanyCreateWithoutChallengesInput {
  id?: Maybe<ID_Input>;
  name?: Maybe<String>;
  type?: Maybe<CompanyType>;
  address?: Maybe<AddressCreateOneInput>;
  users?: Maybe<UserCreateManyWithoutCompanyInput>;
  emailDomains?: Maybe<CompanyCreateemailDomainsInput>;
  stripeCustomerId?: Maybe<String>;
}

export interface AddressCreateOneInput {
  create?: Maybe<AddressCreateInput>;
}

export interface AddressCreateInput {
  street?: Maybe<String>;
  zipCode?: Maybe<String>;
  city?: Maybe<String>;
  location?: Maybe<PointCreateOneInput>;
}

export interface PointCreateOneInput {
  create?: Maybe<PointCreateInput>;
}

export interface PointCreateInput {
  type?: Maybe<String>;
  coordinates?: Maybe<PointCreatecoordinatesInput>;
}

export interface PointCreatecoordinatesInput {
  set?: Maybe<Float[] | Float>;
}

export interface UserCreateManyWithoutCompanyInput {
  create?: Maybe<
    UserCreateWithoutCompanyInput[] | UserCreateWithoutCompanyInput
  >;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
}

export interface UserCreateWithoutCompanyInput {
  id?: Maybe<ID_Input>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  email?: Maybe<String>;
  phone?: Maybe<String>;
  password?: Maybe<String>;
  role?: Maybe<Role>;
  isRepresentative?: Maybe<Boolean>;
  points?: Maybe<Int>;
  validatedChallenges?: Maybe<ChallengeCreateManyInput>;
  validatedQuizzes?: Maybe<ValidatedQuizCreateManyInput>;
}

export interface ChallengeCreateManyInput {
  create?: Maybe<ChallengeCreateInput[] | ChallengeCreateInput>;
  connect?: Maybe<ChallengeWhereUniqueInput[] | ChallengeWhereUniqueInput>;
}

export interface ValidatedQuizCreateManyInput {
  create?: Maybe<ValidatedQuizCreateInput[] | ValidatedQuizCreateInput>;
  connect?: Maybe<
    ValidatedQuizWhereUniqueInput[] | ValidatedQuizWhereUniqueInput
  >;
}

export interface ValidatedQuizCreateInput {
  id?: Maybe<ID_Input>;
  article: ArticleCreateOneInput;
  status: Boolean;
}

export interface ArticleCreateOneInput {
  create?: Maybe<ArticleCreateInput>;
  connect?: Maybe<ArticleWhereUniqueInput>;
}

export interface CompanyCreateemailDomainsInput {
  set?: Maybe<String[] | String>;
}

export interface ChallengeUpdateInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  category?: Maybe<ChallengeCategory>;
  value?: Maybe<Int>;
  companies?: Maybe<CompanyUpdateManyWithoutChallengesInput>;
}

export interface CompanyUpdateManyWithoutChallengesInput {
  create?: Maybe<
    CompanyCreateWithoutChallengesInput[] | CompanyCreateWithoutChallengesInput
  >;
  delete?: Maybe<CompanyWhereUniqueInput[] | CompanyWhereUniqueInput>;
  connect?: Maybe<CompanyWhereUniqueInput[] | CompanyWhereUniqueInput>;
  set?: Maybe<CompanyWhereUniqueInput[] | CompanyWhereUniqueInput>;
  disconnect?: Maybe<CompanyWhereUniqueInput[] | CompanyWhereUniqueInput>;
  update?: Maybe<
    | CompanyUpdateWithWhereUniqueWithoutChallengesInput[]
    | CompanyUpdateWithWhereUniqueWithoutChallengesInput
  >;
  upsert?: Maybe<
    | CompanyUpsertWithWhereUniqueWithoutChallengesInput[]
    | CompanyUpsertWithWhereUniqueWithoutChallengesInput
  >;
  deleteMany?: Maybe<CompanyScalarWhereInput[] | CompanyScalarWhereInput>;
  updateMany?: Maybe<
    | CompanyUpdateManyWithWhereNestedInput[]
    | CompanyUpdateManyWithWhereNestedInput
  >;
}

export interface CompanyUpdateWithWhereUniqueWithoutChallengesInput {
  where: CompanyWhereUniqueInput;
  data: CompanyUpdateWithoutChallengesDataInput;
}

export interface CompanyUpdateWithoutChallengesDataInput {
  name?: Maybe<String>;
  type?: Maybe<CompanyType>;
  address?: Maybe<AddressUpdateOneInput>;
  users?: Maybe<UserUpdateManyWithoutCompanyInput>;
  emailDomains?: Maybe<CompanyUpdateemailDomainsInput>;
  stripeCustomerId?: Maybe<String>;
}

export interface AddressUpdateOneInput {
  create?: Maybe<AddressCreateInput>;
  update?: Maybe<AddressUpdateDataInput>;
  upsert?: Maybe<AddressUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
}

export interface AddressUpdateDataInput {
  street?: Maybe<String>;
  zipCode?: Maybe<String>;
  city?: Maybe<String>;
  location?: Maybe<PointUpdateOneInput>;
}

export interface PointUpdateOneInput {
  create?: Maybe<PointCreateInput>;
  update?: Maybe<PointUpdateDataInput>;
  upsert?: Maybe<PointUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
}

export interface PointUpdateDataInput {
  type?: Maybe<String>;
  coordinates?: Maybe<PointUpdatecoordinatesInput>;
}

export interface PointUpdatecoordinatesInput {
  set?: Maybe<Float[] | Float>;
}

export interface PointUpsertNestedInput {
  update: PointUpdateDataInput;
  create: PointCreateInput;
}

export interface AddressUpsertNestedInput {
  update: AddressUpdateDataInput;
  create: AddressCreateInput;
}

export interface UserUpdateManyWithoutCompanyInput {
  create?: Maybe<
    UserCreateWithoutCompanyInput[] | UserCreateWithoutCompanyInput
  >;
  delete?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  set?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  disconnect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  update?: Maybe<
    | UserUpdateWithWhereUniqueWithoutCompanyInput[]
    | UserUpdateWithWhereUniqueWithoutCompanyInput
  >;
  upsert?: Maybe<
    | UserUpsertWithWhereUniqueWithoutCompanyInput[]
    | UserUpsertWithWhereUniqueWithoutCompanyInput
  >;
  deleteMany?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  updateMany?: Maybe<
    UserUpdateManyWithWhereNestedInput[] | UserUpdateManyWithWhereNestedInput
  >;
}

export interface UserUpdateWithWhereUniqueWithoutCompanyInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutCompanyDataInput;
}

export interface UserUpdateWithoutCompanyDataInput {
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  email?: Maybe<String>;
  phone?: Maybe<String>;
  password?: Maybe<String>;
  role?: Maybe<Role>;
  isRepresentative?: Maybe<Boolean>;
  points?: Maybe<Int>;
  validatedChallenges?: Maybe<ChallengeUpdateManyInput>;
  validatedQuizzes?: Maybe<ValidatedQuizUpdateManyInput>;
}

export interface ChallengeUpdateManyInput {
  create?: Maybe<ChallengeCreateInput[] | ChallengeCreateInput>;
  update?: Maybe<
    | ChallengeUpdateWithWhereUniqueNestedInput[]
    | ChallengeUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | ChallengeUpsertWithWhereUniqueNestedInput[]
    | ChallengeUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<ChallengeWhereUniqueInput[] | ChallengeWhereUniqueInput>;
  connect?: Maybe<ChallengeWhereUniqueInput[] | ChallengeWhereUniqueInput>;
  set?: Maybe<ChallengeWhereUniqueInput[] | ChallengeWhereUniqueInput>;
  disconnect?: Maybe<ChallengeWhereUniqueInput[] | ChallengeWhereUniqueInput>;
  deleteMany?: Maybe<ChallengeScalarWhereInput[] | ChallengeScalarWhereInput>;
  updateMany?: Maybe<
    | ChallengeUpdateManyWithWhereNestedInput[]
    | ChallengeUpdateManyWithWhereNestedInput
  >;
}

export interface ChallengeUpdateWithWhereUniqueNestedInput {
  where: ChallengeWhereUniqueInput;
  data: ChallengeUpdateDataInput;
}

export interface ChallengeUpdateDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  category?: Maybe<ChallengeCategory>;
  value?: Maybe<Int>;
  companies?: Maybe<CompanyUpdateManyWithoutChallengesInput>;
}

export interface ChallengeUpsertWithWhereUniqueNestedInput {
  where: ChallengeWhereUniqueInput;
  update: ChallengeUpdateDataInput;
  create: ChallengeCreateInput;
}

export interface ChallengeScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  category?: Maybe<ChallengeCategory>;
  category_not?: Maybe<ChallengeCategory>;
  category_in?: Maybe<ChallengeCategory[] | ChallengeCategory>;
  category_not_in?: Maybe<ChallengeCategory[] | ChallengeCategory>;
  value?: Maybe<Int>;
  value_not?: Maybe<Int>;
  value_in?: Maybe<Int[] | Int>;
  value_not_in?: Maybe<Int[] | Int>;
  value_lt?: Maybe<Int>;
  value_lte?: Maybe<Int>;
  value_gt?: Maybe<Int>;
  value_gte?: Maybe<Int>;
  AND?: Maybe<ChallengeScalarWhereInput[] | ChallengeScalarWhereInput>;
  OR?: Maybe<ChallengeScalarWhereInput[] | ChallengeScalarWhereInput>;
  NOT?: Maybe<ChallengeScalarWhereInput[] | ChallengeScalarWhereInput>;
}

export interface ChallengeUpdateManyWithWhereNestedInput {
  where: ChallengeScalarWhereInput;
  data: ChallengeUpdateManyDataInput;
}

export interface ChallengeUpdateManyDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  category?: Maybe<ChallengeCategory>;
  value?: Maybe<Int>;
}

export interface ValidatedQuizUpdateManyInput {
  create?: Maybe<ValidatedQuizCreateInput[] | ValidatedQuizCreateInput>;
  update?: Maybe<
    | ValidatedQuizUpdateWithWhereUniqueNestedInput[]
    | ValidatedQuizUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | ValidatedQuizUpsertWithWhereUniqueNestedInput[]
    | ValidatedQuizUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<
    ValidatedQuizWhereUniqueInput[] | ValidatedQuizWhereUniqueInput
  >;
  connect?: Maybe<
    ValidatedQuizWhereUniqueInput[] | ValidatedQuizWhereUniqueInput
  >;
  set?: Maybe<ValidatedQuizWhereUniqueInput[] | ValidatedQuizWhereUniqueInput>;
  disconnect?: Maybe<
    ValidatedQuizWhereUniqueInput[] | ValidatedQuizWhereUniqueInput
  >;
  deleteMany?: Maybe<
    ValidatedQuizScalarWhereInput[] | ValidatedQuizScalarWhereInput
  >;
  updateMany?: Maybe<
    | ValidatedQuizUpdateManyWithWhereNestedInput[]
    | ValidatedQuizUpdateManyWithWhereNestedInput
  >;
}

export interface ValidatedQuizUpdateWithWhereUniqueNestedInput {
  where: ValidatedQuizWhereUniqueInput;
  data: ValidatedQuizUpdateDataInput;
}

export interface ValidatedQuizUpdateDataInput {
  article?: Maybe<ArticleUpdateOneRequiredInput>;
  status?: Maybe<Boolean>;
}

export interface ArticleUpdateOneRequiredInput {
  create?: Maybe<ArticleCreateInput>;
  update?: Maybe<ArticleUpdateDataInput>;
  upsert?: Maybe<ArticleUpsertNestedInput>;
  connect?: Maybe<ArticleWhereUniqueInput>;
}

export interface ArticleUpdateDataInput {
  title?: Maybe<String>;
  content?: Maybe<String>;
  picture?: Maybe<String>;
  video?: Maybe<String>;
  quiz?: Maybe<QuizUpdateOneInput>;
  date?: Maybe<String>;
}

export interface ArticleUpsertNestedInput {
  update: ArticleUpdateDataInput;
  create: ArticleCreateInput;
}

export interface ValidatedQuizUpsertWithWhereUniqueNestedInput {
  where: ValidatedQuizWhereUniqueInput;
  update: ValidatedQuizUpdateDataInput;
  create: ValidatedQuizCreateInput;
}

export interface ValidatedQuizScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  status?: Maybe<Boolean>;
  status_not?: Maybe<Boolean>;
  AND?: Maybe<ValidatedQuizScalarWhereInput[] | ValidatedQuizScalarWhereInput>;
  OR?: Maybe<ValidatedQuizScalarWhereInput[] | ValidatedQuizScalarWhereInput>;
  NOT?: Maybe<ValidatedQuizScalarWhereInput[] | ValidatedQuizScalarWhereInput>;
}

export interface ValidatedQuizUpdateManyWithWhereNestedInput {
  where: ValidatedQuizScalarWhereInput;
  data: ValidatedQuizUpdateManyDataInput;
}

export interface ValidatedQuizUpdateManyDataInput {
  status?: Maybe<Boolean>;
}

export interface UserUpsertWithWhereUniqueWithoutCompanyInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutCompanyDataInput;
  create: UserCreateWithoutCompanyInput;
}

export interface UserScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  firstName?: Maybe<String>;
  firstName_not?: Maybe<String>;
  firstName_in?: Maybe<String[] | String>;
  firstName_not_in?: Maybe<String[] | String>;
  firstName_lt?: Maybe<String>;
  firstName_lte?: Maybe<String>;
  firstName_gt?: Maybe<String>;
  firstName_gte?: Maybe<String>;
  firstName_contains?: Maybe<String>;
  firstName_not_contains?: Maybe<String>;
  firstName_starts_with?: Maybe<String>;
  firstName_not_starts_with?: Maybe<String>;
  firstName_ends_with?: Maybe<String>;
  firstName_not_ends_with?: Maybe<String>;
  lastName?: Maybe<String>;
  lastName_not?: Maybe<String>;
  lastName_in?: Maybe<String[] | String>;
  lastName_not_in?: Maybe<String[] | String>;
  lastName_lt?: Maybe<String>;
  lastName_lte?: Maybe<String>;
  lastName_gt?: Maybe<String>;
  lastName_gte?: Maybe<String>;
  lastName_contains?: Maybe<String>;
  lastName_not_contains?: Maybe<String>;
  lastName_starts_with?: Maybe<String>;
  lastName_not_starts_with?: Maybe<String>;
  lastName_ends_with?: Maybe<String>;
  lastName_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  phone?: Maybe<String>;
  phone_not?: Maybe<String>;
  phone_in?: Maybe<String[] | String>;
  phone_not_in?: Maybe<String[] | String>;
  phone_lt?: Maybe<String>;
  phone_lte?: Maybe<String>;
  phone_gt?: Maybe<String>;
  phone_gte?: Maybe<String>;
  phone_contains?: Maybe<String>;
  phone_not_contains?: Maybe<String>;
  phone_starts_with?: Maybe<String>;
  phone_not_starts_with?: Maybe<String>;
  phone_ends_with?: Maybe<String>;
  phone_not_ends_with?: Maybe<String>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  role?: Maybe<Role>;
  role_not?: Maybe<Role>;
  role_in?: Maybe<Role[] | Role>;
  role_not_in?: Maybe<Role[] | Role>;
  isRepresentative?: Maybe<Boolean>;
  isRepresentative_not?: Maybe<Boolean>;
  points?: Maybe<Int>;
  points_not?: Maybe<Int>;
  points_in?: Maybe<Int[] | Int>;
  points_not_in?: Maybe<Int[] | Int>;
  points_lt?: Maybe<Int>;
  points_lte?: Maybe<Int>;
  points_gt?: Maybe<Int>;
  points_gte?: Maybe<Int>;
  AND?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  OR?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  NOT?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
}

export interface UserUpdateManyWithWhereNestedInput {
  where: UserScalarWhereInput;
  data: UserUpdateManyDataInput;
}

export interface UserUpdateManyDataInput {
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  email?: Maybe<String>;
  phone?: Maybe<String>;
  password?: Maybe<String>;
  role?: Maybe<Role>;
  isRepresentative?: Maybe<Boolean>;
  points?: Maybe<Int>;
}

export interface CompanyUpdateemailDomainsInput {
  set?: Maybe<String[] | String>;
}

export interface CompanyUpsertWithWhereUniqueWithoutChallengesInput {
  where: CompanyWhereUniqueInput;
  update: CompanyUpdateWithoutChallengesDataInput;
  create: CompanyCreateWithoutChallengesInput;
}

export interface CompanyScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  type?: Maybe<CompanyType>;
  type_not?: Maybe<CompanyType>;
  type_in?: Maybe<CompanyType[] | CompanyType>;
  type_not_in?: Maybe<CompanyType[] | CompanyType>;
  stripeCustomerId?: Maybe<String>;
  stripeCustomerId_not?: Maybe<String>;
  stripeCustomerId_in?: Maybe<String[] | String>;
  stripeCustomerId_not_in?: Maybe<String[] | String>;
  stripeCustomerId_lt?: Maybe<String>;
  stripeCustomerId_lte?: Maybe<String>;
  stripeCustomerId_gt?: Maybe<String>;
  stripeCustomerId_gte?: Maybe<String>;
  stripeCustomerId_contains?: Maybe<String>;
  stripeCustomerId_not_contains?: Maybe<String>;
  stripeCustomerId_starts_with?: Maybe<String>;
  stripeCustomerId_not_starts_with?: Maybe<String>;
  stripeCustomerId_ends_with?: Maybe<String>;
  stripeCustomerId_not_ends_with?: Maybe<String>;
  AND?: Maybe<CompanyScalarWhereInput[] | CompanyScalarWhereInput>;
  OR?: Maybe<CompanyScalarWhereInput[] | CompanyScalarWhereInput>;
  NOT?: Maybe<CompanyScalarWhereInput[] | CompanyScalarWhereInput>;
}

export interface CompanyUpdateManyWithWhereNestedInput {
  where: CompanyScalarWhereInput;
  data: CompanyUpdateManyDataInput;
}

export interface CompanyUpdateManyDataInput {
  name?: Maybe<String>;
  type?: Maybe<CompanyType>;
  emailDomains?: Maybe<CompanyUpdateemailDomainsInput>;
  stripeCustomerId?: Maybe<String>;
}

export interface ChallengeUpdateManyMutationInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  category?: Maybe<ChallengeCategory>;
  value?: Maybe<Int>;
}

export interface CompanyCreateInput {
  id?: Maybe<ID_Input>;
  name?: Maybe<String>;
  type?: Maybe<CompanyType>;
  address?: Maybe<AddressCreateOneInput>;
  users?: Maybe<UserCreateManyWithoutCompanyInput>;
  emailDomains?: Maybe<CompanyCreateemailDomainsInput>;
  stripeCustomerId?: Maybe<String>;
  challenges?: Maybe<ChallengeCreateManyWithoutCompaniesInput>;
}

export interface ChallengeCreateManyWithoutCompaniesInput {
  create?: Maybe<
    | ChallengeCreateWithoutCompaniesInput[]
    | ChallengeCreateWithoutCompaniesInput
  >;
  connect?: Maybe<ChallengeWhereUniqueInput[] | ChallengeWhereUniqueInput>;
}

export interface ChallengeCreateWithoutCompaniesInput {
  id?: Maybe<ID_Input>;
  name: String;
  description: String;
  category?: Maybe<ChallengeCategory>;
  value: Int;
}

export interface CompanyUpdateInput {
  name?: Maybe<String>;
  type?: Maybe<CompanyType>;
  address?: Maybe<AddressUpdateOneInput>;
  users?: Maybe<UserUpdateManyWithoutCompanyInput>;
  emailDomains?: Maybe<CompanyUpdateemailDomainsInput>;
  stripeCustomerId?: Maybe<String>;
  challenges?: Maybe<ChallengeUpdateManyWithoutCompaniesInput>;
}

export interface ChallengeUpdateManyWithoutCompaniesInput {
  create?: Maybe<
    | ChallengeCreateWithoutCompaniesInput[]
    | ChallengeCreateWithoutCompaniesInput
  >;
  delete?: Maybe<ChallengeWhereUniqueInput[] | ChallengeWhereUniqueInput>;
  connect?: Maybe<ChallengeWhereUniqueInput[] | ChallengeWhereUniqueInput>;
  set?: Maybe<ChallengeWhereUniqueInput[] | ChallengeWhereUniqueInput>;
  disconnect?: Maybe<ChallengeWhereUniqueInput[] | ChallengeWhereUniqueInput>;
  update?: Maybe<
    | ChallengeUpdateWithWhereUniqueWithoutCompaniesInput[]
    | ChallengeUpdateWithWhereUniqueWithoutCompaniesInput
  >;
  upsert?: Maybe<
    | ChallengeUpsertWithWhereUniqueWithoutCompaniesInput[]
    | ChallengeUpsertWithWhereUniqueWithoutCompaniesInput
  >;
  deleteMany?: Maybe<ChallengeScalarWhereInput[] | ChallengeScalarWhereInput>;
  updateMany?: Maybe<
    | ChallengeUpdateManyWithWhereNestedInput[]
    | ChallengeUpdateManyWithWhereNestedInput
  >;
}

export interface ChallengeUpdateWithWhereUniqueWithoutCompaniesInput {
  where: ChallengeWhereUniqueInput;
  data: ChallengeUpdateWithoutCompaniesDataInput;
}

export interface ChallengeUpdateWithoutCompaniesDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  category?: Maybe<ChallengeCategory>;
  value?: Maybe<Int>;
}

export interface ChallengeUpsertWithWhereUniqueWithoutCompaniesInput {
  where: ChallengeWhereUniqueInput;
  update: ChallengeUpdateWithoutCompaniesDataInput;
  create: ChallengeCreateWithoutCompaniesInput;
}

export interface CompanyUpdateManyMutationInput {
  name?: Maybe<String>;
  type?: Maybe<CompanyType>;
  emailDomains?: Maybe<CompanyUpdateemailDomainsInput>;
  stripeCustomerId?: Maybe<String>;
}

export interface PhotoCreateInput {
  id?: Maybe<ID_Input>;
  uri: String;
}

export interface PhotoUpdateInput {
  uri?: Maybe<String>;
}

export interface PhotoUpdateManyMutationInput {
  uri?: Maybe<String>;
}

export interface PlaceCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  category: Category;
  address?: Maybe<AddressCreateOneInput>;
  user?: Maybe<UserCreateOneInput>;
  social?: Maybe<SocialCreateOneInput>;
  headline?: Maybe<String>;
  description?: Maybe<String>;
  hours?: Maybe<HourCreateManyInput>;
  tags?: Maybe<TagCreateManyInput>;
  photos?: Maybe<PhotoCreateManyInput>;
}

export interface UserCreateOneInput {
  create?: Maybe<UserCreateInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateInput {
  id?: Maybe<ID_Input>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  email?: Maybe<String>;
  phone?: Maybe<String>;
  password?: Maybe<String>;
  role?: Maybe<Role>;
  isRepresentative?: Maybe<Boolean>;
  company?: Maybe<CompanyCreateOneWithoutUsersInput>;
  points?: Maybe<Int>;
  validatedChallenges?: Maybe<ChallengeCreateManyInput>;
  validatedQuizzes?: Maybe<QuizCreateManyInput>;
}

export interface CompanyCreateOneWithoutUsersInput {
  create?: Maybe<CompanyCreateWithoutUsersInput>;
  connect?: Maybe<CompanyWhereUniqueInput>;
}

export interface CompanyCreateWithoutUsersInput {
  id?: Maybe<ID_Input>;
  name?: Maybe<String>;
  type?: Maybe<CompanyType>;
  address?: Maybe<AddressCreateOneInput>;
  emailDomains?: Maybe<CompanyCreateemailDomainsInput>;
  stripeCustomerId?: Maybe<String>;
  challenges?: Maybe<ChallengeCreateManyWithoutCompaniesInput>;
  quizzes?: Maybe<QuizCreateManyWithoutCompaniesInput>;
}

export interface SocialCreateOneInput {
  create?: Maybe<SocialCreateInput>;
}

export interface SocialCreateInput {
  website?: Maybe<String>;
  facebook?: Maybe<String>;
  instagram?: Maybe<String>;
}

export interface HourCreateManyInput {
  create?: Maybe<HourCreateInput[] | HourCreateInput>;
}

export interface HourCreateInput {
  day?: Maybe<Day>;
  start?: Maybe<String>;
  end?: Maybe<String>;
}

export interface TagCreateManyInput {
  create?: Maybe<TagCreateInput[] | TagCreateInput>;
  connect?: Maybe<TagWhereUniqueInput[] | TagWhereUniqueInput>;
}

export interface TagCreateInput {
  id?: Maybe<ID_Input>;
  label: String;
  children?: Maybe<TagCreateManyInput>;
  root?: Maybe<Boolean>;
  leaf?: Maybe<Boolean>;
  category: Category;
}

export interface PhotoCreateManyInput {
  create?: Maybe<PhotoCreateInput[] | PhotoCreateInput>;
  connect?: Maybe<PhotoWhereUniqueInput[] | PhotoWhereUniqueInput>;
}

export interface PlaceUpdateInput {
  name?: Maybe<String>;
  category?: Maybe<Category>;
  address?: Maybe<AddressUpdateOneInput>;
  user?: Maybe<UserUpdateOneInput>;
  social?: Maybe<SocialUpdateOneInput>;
  headline?: Maybe<String>;
  description?: Maybe<String>;
  hours?: Maybe<HourUpdateManyInput>;
  tags?: Maybe<TagUpdateManyInput>;
  photos?: Maybe<PhotoUpdateManyInput>;
}

export interface UserUpdateOneInput {
  create?: Maybe<UserCreateInput>;
  update?: Maybe<UserUpdateDataInput>;
  upsert?: Maybe<UserUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateDataInput {
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  email?: Maybe<String>;
  phone?: Maybe<String>;
  password?: Maybe<String>;
  role?: Maybe<Role>;
  isRepresentative?: Maybe<Boolean>;
  company?: Maybe<CompanyUpdateOneWithoutUsersInput>;
  points?: Maybe<Int>;
  validatedChallenges?: Maybe<ChallengeUpdateManyInput>;
  validatedQuizzes?: Maybe<QuizUpdateManyInput>;
}

export interface CompanyUpdateOneWithoutUsersInput {
  create?: Maybe<CompanyCreateWithoutUsersInput>;
  update?: Maybe<CompanyUpdateWithoutUsersDataInput>;
  upsert?: Maybe<CompanyUpsertWithoutUsersInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<CompanyWhereUniqueInput>;
}

export interface CompanyUpdateWithoutUsersDataInput {
  name?: Maybe<String>;
  type?: Maybe<CompanyType>;
  address?: Maybe<AddressUpdateOneInput>;
  emailDomains?: Maybe<CompanyUpdateemailDomainsInput>;
  stripeCustomerId?: Maybe<String>;
  challenges?: Maybe<ChallengeUpdateManyWithoutCompaniesInput>;
  quizzes?: Maybe<QuizUpdateManyWithoutCompaniesInput>;
}

export interface CompanyUpsertWithoutUsersInput {
  update: CompanyUpdateWithoutUsersDataInput;
  create: CompanyCreateWithoutUsersInput;
}

export interface UserUpsertNestedInput {
  update: UserUpdateDataInput;
  create: UserCreateInput;
}

export interface SocialUpdateOneInput {
  create?: Maybe<SocialCreateInput>;
  update?: Maybe<SocialUpdateDataInput>;
  upsert?: Maybe<SocialUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
}

export interface SocialUpdateDataInput {
  website?: Maybe<String>;
  facebook?: Maybe<String>;
  instagram?: Maybe<String>;
}

export interface SocialUpsertNestedInput {
  update: SocialUpdateDataInput;
  create: SocialCreateInput;
}

export interface HourUpdateManyInput {
  create?: Maybe<HourCreateInput[] | HourCreateInput>;
  deleteMany?: Maybe<HourScalarWhereInput[] | HourScalarWhereInput>;
  updateMany?: Maybe<
    HourUpdateManyWithWhereNestedInput[] | HourUpdateManyWithWhereNestedInput
  >;
}

export interface HourScalarWhereInput {
  day?: Maybe<Day>;
  day_not?: Maybe<Day>;
  day_in?: Maybe<Day[] | Day>;
  day_not_in?: Maybe<Day[] | Day>;
  start?: Maybe<String>;
  start_not?: Maybe<String>;
  start_in?: Maybe<String[] | String>;
  start_not_in?: Maybe<String[] | String>;
  start_lt?: Maybe<String>;
  start_lte?: Maybe<String>;
  start_gt?: Maybe<String>;
  start_gte?: Maybe<String>;
  start_contains?: Maybe<String>;
  start_not_contains?: Maybe<String>;
  start_starts_with?: Maybe<String>;
  start_not_starts_with?: Maybe<String>;
  start_ends_with?: Maybe<String>;
  start_not_ends_with?: Maybe<String>;
  end?: Maybe<String>;
  end_not?: Maybe<String>;
  end_in?: Maybe<String[] | String>;
  end_not_in?: Maybe<String[] | String>;
  end_lt?: Maybe<String>;
  end_lte?: Maybe<String>;
  end_gt?: Maybe<String>;
  end_gte?: Maybe<String>;
  end_contains?: Maybe<String>;
  end_not_contains?: Maybe<String>;
  end_starts_with?: Maybe<String>;
  end_not_starts_with?: Maybe<String>;
  end_ends_with?: Maybe<String>;
  end_not_ends_with?: Maybe<String>;
  AND?: Maybe<HourScalarWhereInput[] | HourScalarWhereInput>;
  OR?: Maybe<HourScalarWhereInput[] | HourScalarWhereInput>;
  NOT?: Maybe<HourScalarWhereInput[] | HourScalarWhereInput>;
}

export interface HourUpdateManyWithWhereNestedInput {
  where: HourScalarWhereInput;
  data: HourUpdateManyDataInput;
}

export interface HourUpdateManyDataInput {
  day?: Maybe<Day>;
  start?: Maybe<String>;
  end?: Maybe<String>;
}

export interface TagUpdateManyInput {
  create?: Maybe<TagCreateInput[] | TagCreateInput>;
  update?: Maybe<
    TagUpdateWithWhereUniqueNestedInput[] | TagUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    TagUpsertWithWhereUniqueNestedInput[] | TagUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<TagWhereUniqueInput[] | TagWhereUniqueInput>;
  connect?: Maybe<TagWhereUniqueInput[] | TagWhereUniqueInput>;
  set?: Maybe<TagWhereUniqueInput[] | TagWhereUniqueInput>;
  disconnect?: Maybe<TagWhereUniqueInput[] | TagWhereUniqueInput>;
  deleteMany?: Maybe<TagScalarWhereInput[] | TagScalarWhereInput>;
  updateMany?: Maybe<
    TagUpdateManyWithWhereNestedInput[] | TagUpdateManyWithWhereNestedInput
  >;
}

export interface TagUpdateWithWhereUniqueNestedInput {
  where: TagWhereUniqueInput;
  data: TagUpdateDataInput;
}

export interface TagUpdateDataInput {
  label?: Maybe<String>;
  children?: Maybe<TagUpdateManyInput>;
  root?: Maybe<Boolean>;
  leaf?: Maybe<Boolean>;
  category?: Maybe<Category>;
}

export interface TagUpsertWithWhereUniqueNestedInput {
  where: TagWhereUniqueInput;
  update: TagUpdateDataInput;
  create: TagCreateInput;
}

export interface TagScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  label?: Maybe<String>;
  label_not?: Maybe<String>;
  label_in?: Maybe<String[] | String>;
  label_not_in?: Maybe<String[] | String>;
  label_lt?: Maybe<String>;
  label_lte?: Maybe<String>;
  label_gt?: Maybe<String>;
  label_gte?: Maybe<String>;
  label_contains?: Maybe<String>;
  label_not_contains?: Maybe<String>;
  label_starts_with?: Maybe<String>;
  label_not_starts_with?: Maybe<String>;
  label_ends_with?: Maybe<String>;
  label_not_ends_with?: Maybe<String>;
  root?: Maybe<Boolean>;
  root_not?: Maybe<Boolean>;
  leaf?: Maybe<Boolean>;
  leaf_not?: Maybe<Boolean>;
  category?: Maybe<Category>;
  category_not?: Maybe<Category>;
  category_in?: Maybe<Category[] | Category>;
  category_not_in?: Maybe<Category[] | Category>;
  AND?: Maybe<TagScalarWhereInput[] | TagScalarWhereInput>;
  OR?: Maybe<TagScalarWhereInput[] | TagScalarWhereInput>;
  NOT?: Maybe<TagScalarWhereInput[] | TagScalarWhereInput>;
}

export interface TagUpdateManyWithWhereNestedInput {
  where: TagScalarWhereInput;
  data: TagUpdateManyDataInput;
}

export interface TagUpdateManyDataInput {
  label?: Maybe<String>;
  root?: Maybe<Boolean>;
  leaf?: Maybe<Boolean>;
  category?: Maybe<Category>;
}

export interface PhotoUpdateManyInput {
  create?: Maybe<PhotoCreateInput[] | PhotoCreateInput>;
  update?: Maybe<
    | PhotoUpdateWithWhereUniqueNestedInput[]
    | PhotoUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | PhotoUpsertWithWhereUniqueNestedInput[]
    | PhotoUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<PhotoWhereUniqueInput[] | PhotoWhereUniqueInput>;
  connect?: Maybe<PhotoWhereUniqueInput[] | PhotoWhereUniqueInput>;
  set?: Maybe<PhotoWhereUniqueInput[] | PhotoWhereUniqueInput>;
  disconnect?: Maybe<PhotoWhereUniqueInput[] | PhotoWhereUniqueInput>;
  deleteMany?: Maybe<PhotoScalarWhereInput[] | PhotoScalarWhereInput>;
  updateMany?: Maybe<
    PhotoUpdateManyWithWhereNestedInput[] | PhotoUpdateManyWithWhereNestedInput
  >;
}

export interface PhotoUpdateWithWhereUniqueNestedInput {
  where: PhotoWhereUniqueInput;
  data: PhotoUpdateDataInput;
}

export interface PhotoUpdateDataInput {
  uri?: Maybe<String>;
}

export interface PhotoUpsertWithWhereUniqueNestedInput {
  where: PhotoWhereUniqueInput;
  update: PhotoUpdateDataInput;
  create: PhotoCreateInput;
}

export interface PhotoScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  uri?: Maybe<String>;
  uri_not?: Maybe<String>;
  uri_in?: Maybe<String[] | String>;
  uri_not_in?: Maybe<String[] | String>;
  uri_lt?: Maybe<String>;
  uri_lte?: Maybe<String>;
  uri_gt?: Maybe<String>;
  uri_gte?: Maybe<String>;
  uri_contains?: Maybe<String>;
  uri_not_contains?: Maybe<String>;
  uri_starts_with?: Maybe<String>;
  uri_not_starts_with?: Maybe<String>;
  uri_ends_with?: Maybe<String>;
  uri_not_ends_with?: Maybe<String>;
  AND?: Maybe<PhotoScalarWhereInput[] | PhotoScalarWhereInput>;
  OR?: Maybe<PhotoScalarWhereInput[] | PhotoScalarWhereInput>;
  NOT?: Maybe<PhotoScalarWhereInput[] | PhotoScalarWhereInput>;
}

export interface PhotoUpdateManyWithWhereNestedInput {
  where: PhotoScalarWhereInput;
  data: PhotoUpdateManyDataInput;
}

export interface PhotoUpdateManyDataInput {
  uri?: Maybe<String>;
}

export interface PlaceUpdateManyMutationInput {
  name?: Maybe<String>;
  category?: Maybe<Category>;
  headline?: Maybe<String>;
  description?: Maybe<String>;
}

export interface QuizUpdateInput {
  name?: Maybe<String>;
  question?: Maybe<String>;
  choices?: Maybe<QuizUpdatechoicesInput>;
  answer?: Maybe<String>;
  value?: Maybe<Int>;
  companies?: Maybe<CompanyUpdateManyWithoutQuizzesInput>;
}

export interface QuizUpdateManyMutationInput {
  name?: Maybe<String>;
  question?: Maybe<String>;
  choices?: Maybe<QuizUpdatechoicesInput>;
  answer?: Maybe<String>;
  value?: Maybe<Int>;
}

export interface TagUpdateInput {
  label?: Maybe<String>;
  children?: Maybe<TagUpdateManyInput>;
  root?: Maybe<Boolean>;
  leaf?: Maybe<Boolean>;
  category?: Maybe<Category>;
}

export interface TagUpdateManyMutationInput {
  label?: Maybe<String>;
  root?: Maybe<Boolean>;
  leaf?: Maybe<Boolean>;
  category?: Maybe<Category>;
}

export interface UserUpdateInput {
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  email?: Maybe<String>;
  phone?: Maybe<String>;
  password?: Maybe<String>;
  role?: Maybe<Role>;
  isRepresentative?: Maybe<Boolean>;
  company?: Maybe<CompanyUpdateOneWithoutUsersInput>;
  points?: Maybe<Int>;
  validatedChallenges?: Maybe<ChallengeUpdateManyInput>;
  validatedQuizzes?: Maybe<ValidatedQuizUpdateManyInput>;
}

export interface UserUpdateManyMutationInput {
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  email?: Maybe<String>;
  phone?: Maybe<String>;
  password?: Maybe<String>;
  role?: Maybe<Role>;
  isRepresentative?: Maybe<Boolean>;
  points?: Maybe<Int>;
}

export interface ValidatedQuizUpdateInput {
  article?: Maybe<ArticleUpdateOneRequiredInput>;
  status?: Maybe<Boolean>;
}

export interface ValidatedQuizUpdateManyMutationInput {
  status?: Maybe<Boolean>;
}

export interface ArticleSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ArticleWhereInput>;
  AND?: Maybe<ArticleSubscriptionWhereInput[] | ArticleSubscriptionWhereInput>;
}

export interface ChallengeSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ChallengeWhereInput>;
  AND?: Maybe<
    ChallengeSubscriptionWhereInput[] | ChallengeSubscriptionWhereInput
  >;
}

export interface CompanySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CompanyWhereInput>;
  AND?: Maybe<CompanySubscriptionWhereInput[] | CompanySubscriptionWhereInput>;
}

export interface PhotoSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PhotoWhereInput>;
  AND?: Maybe<PhotoSubscriptionWhereInput[] | PhotoSubscriptionWhereInput>;
}

export interface PlaceSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PlaceWhereInput>;
  AND?: Maybe<PlaceSubscriptionWhereInput[] | PlaceSubscriptionWhereInput>;
}

export interface TagSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<TagWhereInput>;
  AND?: Maybe<TagSubscriptionWhereInput[] | TagSubscriptionWhereInput>;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserWhereInput>;
  AND?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
}

export interface ValidatedQuizSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ValidatedQuizWhereInput>;
  AND?: Maybe<
    ValidatedQuizSubscriptionWhereInput[] | ValidatedQuizSubscriptionWhereInput
  >;
}

export interface NodeNode {
  id: ID_Output;
}

export interface Article {
  id: ID_Output;
  title: String;
  content: String;
  picture?: String;
  video?: String;
  quiz?: Quiz | null;
  date: String;
}

export interface ArticlePromise extends Promise<Article>, Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  content: () => Promise<String>;
  picture: () => Promise<String>;
  video: () => Promise<String>;
  quiz: <T = QuizPromise>() => T;
  date: () => Promise<String>;
}

export interface ArticleSubscription
  extends Promise<AsyncIterator<Article>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  content: () => Promise<AsyncIterator<String>>;
  picture: () => Promise<AsyncIterator<String>>;
  video: () => Promise<AsyncIterator<String>>;
  quiz: <T = QuizSubscription>() => T;
  date: () => Promise<AsyncIterator<String>>;
}

export interface ArticleNullablePromise
  extends Promise<Article | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  content: () => Promise<String>;
  picture: () => Promise<String>;
  video: () => Promise<String>;
  quiz: <T = QuizPromise>() => T;
  date: () => Promise<String>;
}

export interface Quiz {
  question: String;
  choices: String[];
  answer: String;
  value: Int;
}

export interface QuizPromise extends Promise<Quiz>, Fragmentable {
  question: () => Promise<String>;
  choices: () => Promise<String[]>;
  answer: () => Promise<String>;
  value: () => Promise<Int>;
}

export interface QuizSubscription
  extends Promise<AsyncIterator<Quiz>>,
    Fragmentable {
  question: () => Promise<AsyncIterator<String>>;
  choices: () => Promise<AsyncIterator<String[]>>;
  answer: () => Promise<AsyncIterator<String>>;
  value: () => Promise<AsyncIterator<Int>>;
}

export interface QuizNullablePromise
  extends Promise<Quiz | null>,
    Fragmentable {
  question: () => Promise<String>;
  choices: () => Promise<String[]>;
  answer: () => Promise<String>;
  value: () => Promise<Int>;
}

export interface ArticleConnection {
  pageInfo: PageInfo;
  edges: ArticleEdge[];
}

export interface ArticleConnectionPromise
  extends Promise<ArticleConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ArticleEdge>>() => T;
  aggregate: <T = AggregateArticlePromise>() => T;
}

export interface ArticleConnectionSubscription
  extends Promise<AsyncIterator<ArticleConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ArticleEdgeSubscription>>>() => T;
  aggregate: <T = AggregateArticleSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface ArticleEdge {
  node: Article;
  cursor: String;
}

export interface ArticleEdgePromise extends Promise<ArticleEdge>, Fragmentable {
  node: <T = ArticlePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ArticleEdgeSubscription
  extends Promise<AsyncIterator<ArticleEdge>>,
    Fragmentable {
  node: <T = ArticleSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateArticle {
  count: Int;
}

export interface AggregateArticlePromise
  extends Promise<AggregateArticle>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateArticleSubscription
  extends Promise<AsyncIterator<AggregateArticle>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Challenge {
  id: ID_Output;
  name: String;
  description: String;
  category?: ChallengeCategory;
  value: Int;
}

export interface ChallengePromise extends Promise<Challenge>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  category: () => Promise<ChallengeCategory>;
  value: () => Promise<Int>;
  companies: <T = FragmentableArray<Company>>(args?: {
    where?: CompanyWhereInput;
    orderBy?: CompanyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ChallengeSubscription
  extends Promise<AsyncIterator<Challenge>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  category: () => Promise<AsyncIterator<ChallengeCategory>>;
  value: () => Promise<AsyncIterator<Int>>;
  companies: <T = Promise<AsyncIterator<CompanySubscription>>>(args?: {
    where?: CompanyWhereInput;
    orderBy?: CompanyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ChallengeNullablePromise
  extends Promise<Challenge | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  category: () => Promise<ChallengeCategory>;
  value: () => Promise<Int>;
  companies: <T = FragmentableArray<Company>>(args?: {
    where?: CompanyWhereInput;
    orderBy?: CompanyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface Company {
  id: ID_Output;
  name?: String;
  type?: CompanyType;
  address?: Address | null;
  emailDomains: String[];
  stripeCustomerId?: String;
}

export interface CompanyPromise extends Promise<Company>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  type: () => Promise<CompanyType>;
  address: <T = AddressPromise>() => T;
  users: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  emailDomains: () => Promise<String[]>;
  stripeCustomerId: () => Promise<String>;
  challenges: <T = FragmentableArray<Challenge>>(args?: {
    where?: ChallengeWhereInput;
    orderBy?: ChallengeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface CompanySubscription
  extends Promise<AsyncIterator<Company>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<CompanyType>>;
  address: <T = AddressSubscription>() => T;
  users: <T = Promise<AsyncIterator<UserSubscription>>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  emailDomains: () => Promise<AsyncIterator<String[]>>;
  stripeCustomerId: () => Promise<AsyncIterator<String>>;
  challenges: <T = Promise<AsyncIterator<ChallengeSubscription>>>(args?: {
    where?: ChallengeWhereInput;
    orderBy?: ChallengeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface CompanyNullablePromise
  extends Promise<Company | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  type: () => Promise<CompanyType>;
  address: <T = AddressPromise>() => T;
  users: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  emailDomains: () => Promise<String[]>;
  stripeCustomerId: () => Promise<String>;
  challenges: <T = FragmentableArray<Challenge>>(args?: {
    where?: ChallengeWhereInput;
    orderBy?: ChallengeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface Address {
  street?: String;
  zipCode?: String;
  city?: String;
  location?: Point | null;
}

export interface AddressPromise extends Promise<Address>, Fragmentable {
  street: () => Promise<String>;
  zipCode: () => Promise<String>;
  city: () => Promise<String>;
  location: <T = PointPromise>() => T;
}

export interface AddressSubscription
  extends Promise<AsyncIterator<Address>>,
    Fragmentable {
  street: () => Promise<AsyncIterator<String>>;
  zipCode: () => Promise<AsyncIterator<String>>;
  city: () => Promise<AsyncIterator<String>>;
  location: <T = PointSubscription>() => T;
}

export interface AddressNullablePromise
  extends Promise<Address | null>,
    Fragmentable {
  street: () => Promise<String>;
  zipCode: () => Promise<String>;
  city: () => Promise<String>;
  location: <T = PointPromise>() => T;
}

export interface Point {
  type?: String;
  coordinates: Float[];
}

export interface PointPromise extends Promise<Point>, Fragmentable {
  type: () => Promise<String>;
  coordinates: () => Promise<Float[]>;
}

export interface PointSubscription
  extends Promise<AsyncIterator<Point>>,
    Fragmentable {
  type: () => Promise<AsyncIterator<String>>;
  coordinates: () => Promise<AsyncIterator<Float[]>>;
}

export interface PointNullablePromise
  extends Promise<Point | null>,
    Fragmentable {
  type: () => Promise<String>;
  coordinates: () => Promise<Float[]>;
}

export interface User {
  id: ID_Output;
  firstName?: String;
  lastName?: String;
  email?: String;
  phone?: String;
  password?: String;
  role?: Role;
  isRepresentative?: Boolean;
  points?: Int;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  email: () => Promise<String>;
  phone: () => Promise<String>;
  password: () => Promise<String>;
  role: () => Promise<Role>;
  isRepresentative: () => Promise<Boolean>;
  company: <T = CompanyPromise>() => T;
  points: () => Promise<Int>;
  validatedChallenges: <T = FragmentableArray<Challenge>>(args?: {
    where?: ChallengeWhereInput;
    orderBy?: ChallengeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  validatedQuizzes: <T = FragmentableArray<ValidatedQuiz>>(args?: {
    where?: ValidatedQuizWhereInput;
    orderBy?: ValidatedQuizOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  role: () => Promise<AsyncIterator<Role>>;
  isRepresentative: () => Promise<AsyncIterator<Boolean>>;
  company: <T = CompanySubscription>() => T;
  points: () => Promise<AsyncIterator<Int>>;
  validatedChallenges: <
    T = Promise<AsyncIterator<ChallengeSubscription>>
  >(args?: {
    where?: ChallengeWhereInput;
    orderBy?: ChallengeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  validatedQuizzes: <
    T = Promise<AsyncIterator<ValidatedQuizSubscription>>
  >(args?: {
    where?: ValidatedQuizWhereInput;
    orderBy?: ValidatedQuizOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface UserNullablePromise
  extends Promise<User | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  email: () => Promise<String>;
  phone: () => Promise<String>;
  password: () => Promise<String>;
  role: () => Promise<Role>;
  isRepresentative: () => Promise<Boolean>;
  company: <T = CompanyPromise>() => T;
  points: () => Promise<Int>;
  validatedChallenges: <T = FragmentableArray<Challenge>>(args?: {
    where?: ChallengeWhereInput;
    orderBy?: ChallengeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  validatedQuizzes: <T = FragmentableArray<ValidatedQuiz>>(args?: {
    where?: ValidatedQuizWhereInput;
    orderBy?: ValidatedQuizOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ValidatedQuiz {
  id: ID_Output;
  status: Boolean;
}

export interface ValidatedQuizPromise
  extends Promise<ValidatedQuiz>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  article: <T = ArticlePromise>() => T;
  status: () => Promise<Boolean>;
}

export interface ValidatedQuizSubscription
  extends Promise<AsyncIterator<ValidatedQuiz>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  article: <T = ArticleSubscription>() => T;
  status: () => Promise<AsyncIterator<Boolean>>;
}

export interface ValidatedQuizNullablePromise
  extends Promise<ValidatedQuiz | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  article: <T = ArticlePromise>() => T;
  status: () => Promise<Boolean>;
}

export interface ChallengeConnection {
  pageInfo: PageInfo;
  edges: ChallengeEdge[];
}

export interface ChallengeConnectionPromise
  extends Promise<ChallengeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ChallengeEdge>>() => T;
  aggregate: <T = AggregateChallengePromise>() => T;
}

export interface ChallengeConnectionSubscription
  extends Promise<AsyncIterator<ChallengeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ChallengeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateChallengeSubscription>() => T;
}

export interface ChallengeEdge {
  node: Challenge;
  cursor: String;
}

export interface ChallengeEdgePromise
  extends Promise<ChallengeEdge>,
    Fragmentable {
  node: <T = ChallengePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ChallengeEdgeSubscription
  extends Promise<AsyncIterator<ChallengeEdge>>,
    Fragmentable {
  node: <T = ChallengeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateChallenge {
  count: Int;
}

export interface AggregateChallengePromise
  extends Promise<AggregateChallenge>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateChallengeSubscription
  extends Promise<AsyncIterator<AggregateChallenge>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CompanyConnection {
  pageInfo: PageInfo;
  edges: CompanyEdge[];
}

export interface CompanyConnectionPromise
  extends Promise<CompanyConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CompanyEdge>>() => T;
  aggregate: <T = AggregateCompanyPromise>() => T;
}

export interface CompanyConnectionSubscription
  extends Promise<AsyncIterator<CompanyConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CompanyEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCompanySubscription>() => T;
}

export interface CompanyEdge {
  node: Company;
  cursor: String;
}

export interface CompanyEdgePromise extends Promise<CompanyEdge>, Fragmentable {
  node: <T = CompanyPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CompanyEdgeSubscription
  extends Promise<AsyncIterator<CompanyEdge>>,
    Fragmentable {
  node: <T = CompanySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCompany {
  count: Int;
}

export interface AggregateCompanyPromise
  extends Promise<AggregateCompany>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCompanySubscription
  extends Promise<AsyncIterator<AggregateCompany>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Photo {
  id: ID_Output;
  uri: String;
}

export interface PhotoPromise extends Promise<Photo>, Fragmentable {
  id: () => Promise<ID_Output>;
  uri: () => Promise<String>;
}

export interface PhotoSubscription
  extends Promise<AsyncIterator<Photo>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  uri: () => Promise<AsyncIterator<String>>;
}

export interface PhotoNullablePromise
  extends Promise<Photo | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  uri: () => Promise<String>;
}

export interface PhotoConnection {
  pageInfo: PageInfo;
  edges: PhotoEdge[];
}

export interface PhotoConnectionPromise
  extends Promise<PhotoConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PhotoEdge>>() => T;
  aggregate: <T = AggregatePhotoPromise>() => T;
}

export interface PhotoConnectionSubscription
  extends Promise<AsyncIterator<PhotoConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PhotoEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePhotoSubscription>() => T;
}

export interface PhotoEdge {
  node: Photo;
  cursor: String;
}

export interface PhotoEdgePromise extends Promise<PhotoEdge>, Fragmentable {
  node: <T = PhotoPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PhotoEdgeSubscription
  extends Promise<AsyncIterator<PhotoEdge>>,
    Fragmentable {
  node: <T = PhotoSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePhoto {
  count: Int;
}

export interface AggregatePhotoPromise
  extends Promise<AggregatePhoto>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePhotoSubscription
  extends Promise<AsyncIterator<AggregatePhoto>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Place {
  id: ID_Output;
  name: String;
  category: Category;
  address?: Address | null;
  social?: Social | null;
  headline?: String;
  description?: String;
  hours?: <T = FragmentableArray<Hour>>() => T;
}

export interface PlacePromise extends Promise<Place>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  category: () => Promise<Category>;
  address: <T = AddressPromise>() => T;
  user: <T = UserPromise>() => T;
  social: <T = SocialPromise>() => T;
  headline: () => Promise<String>;
  description: () => Promise<String>;
  hours: <T = FragmentableArray<Hour>>() => T;
  tags: <T = FragmentableArray<Tag>>(args?: {
    where?: TagWhereInput;
    orderBy?: TagOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  photos: <T = FragmentableArray<Photo>>(args?: {
    where?: PhotoWhereInput;
    orderBy?: PhotoOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface PlaceSubscription
  extends Promise<AsyncIterator<Place>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  category: () => Promise<AsyncIterator<Category>>;
  address: <T = AddressSubscription>() => T;
  user: <T = UserSubscription>() => T;
  social: <T = SocialSubscription>() => T;
  headline: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  hours: <T = Promise<AsyncIterator<HourSubscription>>>() => T;
  tags: <T = Promise<AsyncIterator<TagSubscription>>>(args?: {
    where?: TagWhereInput;
    orderBy?: TagOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  photos: <T = Promise<AsyncIterator<PhotoSubscription>>>(args?: {
    where?: PhotoWhereInput;
    orderBy?: PhotoOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface PlaceNullablePromise
  extends Promise<Place | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  category: () => Promise<Category>;
  address: <T = AddressPromise>() => T;
  user: <T = UserPromise>() => T;
  social: <T = SocialPromise>() => T;
  headline: () => Promise<String>;
  description: () => Promise<String>;
  hours: <T = FragmentableArray<Hour>>() => T;
  tags: <T = FragmentableArray<Tag>>(args?: {
    where?: TagWhereInput;
    orderBy?: TagOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  photos: <T = FragmentableArray<Photo>>(args?: {
    where?: PhotoWhereInput;
    orderBy?: PhotoOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface Social {
  website?: String;
  facebook?: String;
  instagram?: String;
}

export interface SocialPromise extends Promise<Social>, Fragmentable {
  website: () => Promise<String>;
  facebook: () => Promise<String>;
  instagram: () => Promise<String>;
}

export interface SocialSubscription
  extends Promise<AsyncIterator<Social>>,
    Fragmentable {
  website: () => Promise<AsyncIterator<String>>;
  facebook: () => Promise<AsyncIterator<String>>;
  instagram: () => Promise<AsyncIterator<String>>;
}

export interface SocialNullablePromise
  extends Promise<Social | null>,
    Fragmentable {
  website: () => Promise<String>;
  facebook: () => Promise<String>;
  instagram: () => Promise<String>;
}

export interface Hour {
  day?: Day;
  start?: String;
  end?: String;
}

export interface HourPromise extends Promise<Hour>, Fragmentable {
  day: () => Promise<Day>;
  start: () => Promise<String>;
  end: () => Promise<String>;
}

export interface HourSubscription
  extends Promise<AsyncIterator<Hour>>,
    Fragmentable {
  day: () => Promise<AsyncIterator<Day>>;
  start: () => Promise<AsyncIterator<String>>;
  end: () => Promise<AsyncIterator<String>>;
}

export interface HourNullablePromise
  extends Promise<Hour | null>,
    Fragmentable {
  day: () => Promise<Day>;
  start: () => Promise<String>;
  end: () => Promise<String>;
}

export interface Tag {
  id: ID_Output;
  label: String;
  root?: Boolean;
  leaf?: Boolean;
  category: Category;
}

export interface TagPromise extends Promise<Tag>, Fragmentable {
  id: () => Promise<ID_Output>;
  label: () => Promise<String>;
  children: <T = FragmentableArray<Tag>>(args?: {
    where?: TagWhereInput;
    orderBy?: TagOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  root: () => Promise<Boolean>;
  leaf: () => Promise<Boolean>;
  category: () => Promise<Category>;
}

export interface TagSubscription
  extends Promise<AsyncIterator<Tag>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  label: () => Promise<AsyncIterator<String>>;
  children: <T = Promise<AsyncIterator<TagSubscription>>>(args?: {
    where?: TagWhereInput;
    orderBy?: TagOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  root: () => Promise<AsyncIterator<Boolean>>;
  leaf: () => Promise<AsyncIterator<Boolean>>;
  category: () => Promise<AsyncIterator<Category>>;
}

export interface TagNullablePromise extends Promise<Tag | null>, Fragmentable {
  id: () => Promise<ID_Output>;
  label: () => Promise<String>;
  children: <T = FragmentableArray<Tag>>(args?: {
    where?: TagWhereInput;
    orderBy?: TagOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  root: () => Promise<Boolean>;
  leaf: () => Promise<Boolean>;
  category: () => Promise<Category>;
}

export interface PlaceConnection {
  pageInfo: PageInfo;
  edges: PlaceEdge[];
}

export interface PlaceConnectionPromise
  extends Promise<PlaceConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PlaceEdge>>() => T;
  aggregate: <T = AggregatePlacePromise>() => T;
}

export interface PlaceConnectionSubscription
  extends Promise<AsyncIterator<PlaceConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PlaceEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePlaceSubscription>() => T;
}

export interface PlaceEdge {
  node: Place;
  cursor: String;
}

export interface PlaceEdgePromise extends Promise<PlaceEdge>, Fragmentable {
  node: <T = PlacePromise>() => T;
  cursor: () => Promise<String>;
}

export interface PlaceEdgeSubscription
  extends Promise<AsyncIterator<PlaceEdge>>,
    Fragmentable {
  node: <T = PlaceSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePlace {
  count: Int;
}

export interface AggregatePlacePromise
  extends Promise<AggregatePlace>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePlaceSubscription
  extends Promise<AsyncIterator<AggregatePlace>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TagConnection {
  pageInfo: PageInfo;
  edges: TagEdge[];
}

export interface TagConnectionPromise
  extends Promise<TagConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TagEdge>>() => T;
  aggregate: <T = AggregateTagPromise>() => T;
}

export interface TagConnectionSubscription
  extends Promise<AsyncIterator<TagConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TagEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTagSubscription>() => T;
}

export interface TagEdge {
  node: Tag;
  cursor: String;
}

export interface TagEdgePromise extends Promise<TagEdge>, Fragmentable {
  node: <T = TagPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TagEdgeSubscription
  extends Promise<AsyncIterator<TagEdge>>,
    Fragmentable {
  node: <T = TagSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateTag {
  count: Int;
}

export interface AggregateTagPromise
  extends Promise<AggregateTag>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTagSubscription
  extends Promise<AsyncIterator<AggregateTag>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ValidatedQuizConnection {
  pageInfo: PageInfo;
  edges: ValidatedQuizEdge[];
}

export interface ValidatedQuizConnectionPromise
  extends Promise<ValidatedQuizConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ValidatedQuizEdge>>() => T;
  aggregate: <T = AggregateValidatedQuizPromise>() => T;
}

export interface ValidatedQuizConnectionSubscription
  extends Promise<AsyncIterator<ValidatedQuizConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ValidatedQuizEdgeSubscription>>>() => T;
  aggregate: <T = AggregateValidatedQuizSubscription>() => T;
}

export interface ValidatedQuizEdge {
  node: ValidatedQuiz;
  cursor: String;
}

export interface ValidatedQuizEdgePromise
  extends Promise<ValidatedQuizEdge>,
    Fragmentable {
  node: <T = ValidatedQuizPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ValidatedQuizEdgeSubscription
  extends Promise<AsyncIterator<ValidatedQuizEdge>>,
    Fragmentable {
  node: <T = ValidatedQuizSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateValidatedQuiz {
  count: Int;
}

export interface AggregateValidatedQuizPromise
  extends Promise<AggregateValidatedQuiz>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateValidatedQuizSubscription
  extends Promise<AsyncIterator<AggregateValidatedQuiz>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface ArticleSubscriptionPayload {
  mutation: MutationType;
  node: Article;
  updatedFields: String[];
  previousValues: ArticlePreviousValues;
}

export interface ArticleSubscriptionPayloadPromise
  extends Promise<ArticleSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ArticlePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ArticlePreviousValuesPromise>() => T;
}

export interface ArticleSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ArticleSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ArticleSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ArticlePreviousValuesSubscription>() => T;
}

export interface ArticlePreviousValues {
  id: ID_Output;
  title: String;
  content: String;
  picture?: String;
  video?: String;
  date: String;
}

export interface ArticlePreviousValuesPromise
  extends Promise<ArticlePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  content: () => Promise<String>;
  picture: () => Promise<String>;
  video: () => Promise<String>;
  date: () => Promise<String>;
}

export interface ArticlePreviousValuesSubscription
  extends Promise<AsyncIterator<ArticlePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  content: () => Promise<AsyncIterator<String>>;
  picture: () => Promise<AsyncIterator<String>>;
  video: () => Promise<AsyncIterator<String>>;
  date: () => Promise<AsyncIterator<String>>;
}

export interface ChallengeSubscriptionPayload {
  mutation: MutationType;
  node: Challenge;
  updatedFields: String[];
  previousValues: ChallengePreviousValues;
}

export interface ChallengeSubscriptionPayloadPromise
  extends Promise<ChallengeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ChallengePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ChallengePreviousValuesPromise>() => T;
}

export interface ChallengeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ChallengeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ChallengeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ChallengePreviousValuesSubscription>() => T;
}

export interface ChallengePreviousValues {
  id: ID_Output;
  name: String;
  description: String;
  category?: ChallengeCategory;
  value: Int;
}

export interface ChallengePreviousValuesPromise
  extends Promise<ChallengePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  category: () => Promise<ChallengeCategory>;
  value: () => Promise<Int>;
}

export interface ChallengePreviousValuesSubscription
  extends Promise<AsyncIterator<ChallengePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  category: () => Promise<AsyncIterator<ChallengeCategory>>;
  value: () => Promise<AsyncIterator<Int>>;
}

export interface CompanySubscriptionPayload {
  mutation: MutationType;
  node: Company;
  updatedFields: String[];
  previousValues: CompanyPreviousValues;
}

export interface CompanySubscriptionPayloadPromise
  extends Promise<CompanySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CompanyPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CompanyPreviousValuesPromise>() => T;
}

export interface CompanySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CompanySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CompanySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CompanyPreviousValuesSubscription>() => T;
}

export interface CompanyPreviousValues {
  id: ID_Output;
  name?: String;
  type?: CompanyType;
  emailDomains: String[];
  stripeCustomerId?: String;
}

export interface CompanyPreviousValuesPromise
  extends Promise<CompanyPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  type: () => Promise<CompanyType>;
  emailDomains: () => Promise<String[]>;
  stripeCustomerId: () => Promise<String>;
}

export interface CompanyPreviousValuesSubscription
  extends Promise<AsyncIterator<CompanyPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<CompanyType>>;
  emailDomains: () => Promise<AsyncIterator<String[]>>;
  stripeCustomerId: () => Promise<AsyncIterator<String>>;
}

export interface PhotoSubscriptionPayload {
  mutation: MutationType;
  node: Photo;
  updatedFields: String[];
  previousValues: PhotoPreviousValues;
}

export interface PhotoSubscriptionPayloadPromise
  extends Promise<PhotoSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PhotoPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PhotoPreviousValuesPromise>() => T;
}

export interface PhotoSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PhotoSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PhotoSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PhotoPreviousValuesSubscription>() => T;
}

export interface PhotoPreviousValues {
  id: ID_Output;
  uri: String;
}

export interface PhotoPreviousValuesPromise
  extends Promise<PhotoPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  uri: () => Promise<String>;
}

export interface PhotoPreviousValuesSubscription
  extends Promise<AsyncIterator<PhotoPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  uri: () => Promise<AsyncIterator<String>>;
}

export interface PlaceSubscriptionPayload {
  mutation: MutationType;
  node: Place;
  updatedFields: String[];
  previousValues: PlacePreviousValues;
}

export interface PlaceSubscriptionPayloadPromise
  extends Promise<PlaceSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PlacePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PlacePreviousValuesPromise>() => T;
}

export interface PlaceSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PlaceSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PlaceSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PlacePreviousValuesSubscription>() => T;
}

export interface PlacePreviousValues {
  id: ID_Output;
  name: String;
  category: Category;
  headline?: String;
  description?: String;
}

export interface PlacePreviousValuesPromise
  extends Promise<PlacePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  category: () => Promise<Category>;
  headline: () => Promise<String>;
  description: () => Promise<String>;
}

export interface PlacePreviousValuesSubscription
  extends Promise<AsyncIterator<PlacePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  category: () => Promise<AsyncIterator<Category>>;
  headline: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
}

export interface TagSubscriptionPayload {
  mutation: MutationType;
  node: Tag;
  updatedFields: String[];
  previousValues: TagPreviousValues;
}

export interface TagSubscriptionPayloadPromise
  extends Promise<TagSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TagPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TagPreviousValuesPromise>() => T;
}

export interface TagSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TagSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TagSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TagPreviousValuesSubscription>() => T;
}

export interface TagPreviousValues {
  id: ID_Output;
  label: String;
  root?: Boolean;
  leaf?: Boolean;
  category: Category;
}

export interface TagPreviousValuesPromise
  extends Promise<TagPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  label: () => Promise<String>;
  root: () => Promise<Boolean>;
  leaf: () => Promise<Boolean>;
  category: () => Promise<Category>;
}

export interface TagPreviousValuesSubscription
  extends Promise<AsyncIterator<TagPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  label: () => Promise<AsyncIterator<String>>;
  root: () => Promise<AsyncIterator<Boolean>>;
  leaf: () => Promise<AsyncIterator<Boolean>>;
  category: () => Promise<AsyncIterator<Category>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface UserPreviousValues {
  id: ID_Output;
  firstName?: String;
  lastName?: String;
  email?: String;
  phone?: String;
  password?: String;
  role?: Role;
  isRepresentative?: Boolean;
  points?: Int;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  email: () => Promise<String>;
  phone: () => Promise<String>;
  password: () => Promise<String>;
  role: () => Promise<Role>;
  isRepresentative: () => Promise<Boolean>;
  points: () => Promise<Int>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  role: () => Promise<AsyncIterator<Role>>;
  isRepresentative: () => Promise<AsyncIterator<Boolean>>;
  points: () => Promise<AsyncIterator<Int>>;
}

export interface ValidatedQuizSubscriptionPayload {
  mutation: MutationType;
  node: ValidatedQuiz;
  updatedFields: String[];
  previousValues: ValidatedQuizPreviousValues;
}

export interface ValidatedQuizSubscriptionPayloadPromise
  extends Promise<ValidatedQuizSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ValidatedQuizPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ValidatedQuizPreviousValuesPromise>() => T;
}

export interface ValidatedQuizSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ValidatedQuizSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ValidatedQuizSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ValidatedQuizPreviousValuesSubscription>() => T;
}

export interface ValidatedQuizPreviousValues {
  id: ID_Output;
  status: Boolean;
}

export interface ValidatedQuizPreviousValuesPromise
  extends Promise<ValidatedQuizPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  status: () => Promise<Boolean>;
}

export interface ValidatedQuizPreviousValuesSubscription
  extends Promise<AsyncIterator<ValidatedQuizPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  status: () => Promise<AsyncIterator<Boolean>>;
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).
*/
export type Float = number;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "User",
    embedded: false
  },
  {
    name: "Place",
    embedded: false
  },
  {
    name: "Company",
    embedded: false
  },
  {
    name: "Tag",
    embedded: false
  },
  {
    name: "Photo",
    embedded: false
  },
  {
    name: "Address",
    embedded: true
  },
  {
    name: "Point",
    embedded: true
  },
  {
    name: "Hour",
    embedded: true
  },
  {
    name: "Social",
    embedded: true
  },
  {
    name: "Quiz",
    embedded: true
  },
  {
    name: "ValidatedQuiz",
    embedded: false
  },
  {
    name: "Challenge",
    embedded: false
  },
  {
    name: "CompanyType",
    embedded: false
  },
  {
    name: "Day",
    embedded: false
  },
  {
    name: "PlaceCategory",
    embedded: false
  },
  {
    name: "ChallengeCategory",
    embedded: false
  },
  {
    name: "Role",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
