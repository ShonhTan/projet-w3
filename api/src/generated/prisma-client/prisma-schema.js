module.exports = {
        typeDefs: // Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

/* GraphQL */ `type Address {
  street: String
  zipCode: String
  city: String
}

input AddressCreateInput {
  street: String
  zipCode: String
  city: String
}

input AddressCreateOneInput {
  create: AddressCreateInput
}

input AddressUpdateDataInput {
  street: String
  zipCode: String
  city: String
}

input AddressUpdateOneInput {
  create: AddressCreateInput
  update: AddressUpdateDataInput
  upsert: AddressUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
}

input AddressUpsertNestedInput {
  update: AddressUpdateDataInput!
  create: AddressCreateInput!
}

input AddressWhereInput {
  street: String
  street_not: String
  street_in: [String!]
  street_not_in: [String!]
  street_lt: String
  street_lte: String
  street_gt: String
  street_gte: String
  street_contains: String
  street_not_contains: String
  street_starts_with: String
  street_not_starts_with: String
  street_ends_with: String
  street_not_ends_with: String
  zipCode: String
  zipCode_not: String
  zipCode_in: [String!]
  zipCode_not_in: [String!]
  zipCode_lt: String
  zipCode_lte: String
  zipCode_gt: String
  zipCode_gte: String
  zipCode_contains: String
  zipCode_not_contains: String
  zipCode_starts_with: String
  zipCode_not_starts_with: String
  zipCode_ends_with: String
  zipCode_not_ends_with: String
  city: String
  city_not: String
  city_in: [String!]
  city_not_in: [String!]
  city_lt: String
  city_lte: String
  city_gt: String
  city_gte: String
  city_contains: String
  city_not_contains: String
  city_starts_with: String
  city_not_starts_with: String
  city_ends_with: String
  city_not_ends_with: String
  AND: [AddressWhereInput!]
}

type AggregateChallenge {
  count: Int!
}

type AggregateCompany {
  count: Int!
}

type AggregatePlace {
  count: Int!
}

type AggregateQuiz {
  count: Int!
}

type AggregateTag {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type BatchPayload {
  count: Long!
}

enum Category {
  FOOD
  SHOP
  ACTIVITY
}

type Challenge {
  id: ID!
  name: String!
  description: String!
  value: Int!
  companies(where: CompanyWhereInput, orderBy: CompanyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Company!]
}

type ChallengeConnection {
  pageInfo: PageInfo!
  edges: [ChallengeEdge]!
  aggregate: AggregateChallenge!
}

input ChallengeCreateInput {
  id: ID
  name: String!
  description: String!
  value: Int!
  companies: CompanyCreateManyWithoutChallengesInput
}

input ChallengeCreateManyInput {
  create: [ChallengeCreateInput!]
  connect: [ChallengeWhereUniqueInput!]
}

input ChallengeCreateManyWithoutCompaniesInput {
  create: [ChallengeCreateWithoutCompaniesInput!]
  connect: [ChallengeWhereUniqueInput!]
}

input ChallengeCreateWithoutCompaniesInput {
  id: ID
  name: String!
  description: String!
  value: Int!
}

type ChallengeEdge {
  node: Challenge!
  cursor: String!
}

enum ChallengeOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  description_ASC
  description_DESC
  value_ASC
  value_DESC
}

type ChallengePreviousValues {
  id: ID!
  name: String!
  description: String!
  value: Int!
}

input ChallengeScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  value: Int
  value_not: Int
  value_in: [Int!]
  value_not_in: [Int!]
  value_lt: Int
  value_lte: Int
  value_gt: Int
  value_gte: Int
  AND: [ChallengeScalarWhereInput!]
  OR: [ChallengeScalarWhereInput!]
  NOT: [ChallengeScalarWhereInput!]
}

type ChallengeSubscriptionPayload {
  mutation: MutationType!
  node: Challenge
  updatedFields: [String!]
  previousValues: ChallengePreviousValues
}

input ChallengeSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ChallengeWhereInput
  AND: [ChallengeSubscriptionWhereInput!]
}

input ChallengeUpdateDataInput {
  name: String
  description: String
  value: Int
  companies: CompanyUpdateManyWithoutChallengesInput
}

input ChallengeUpdateInput {
  name: String
  description: String
  value: Int
  companies: CompanyUpdateManyWithoutChallengesInput
}

input ChallengeUpdateManyDataInput {
  name: String
  description: String
  value: Int
}

input ChallengeUpdateManyInput {
  create: [ChallengeCreateInput!]
  update: [ChallengeUpdateWithWhereUniqueNestedInput!]
  upsert: [ChallengeUpsertWithWhereUniqueNestedInput!]
  delete: [ChallengeWhereUniqueInput!]
  connect: [ChallengeWhereUniqueInput!]
  set: [ChallengeWhereUniqueInput!]
  disconnect: [ChallengeWhereUniqueInput!]
  deleteMany: [ChallengeScalarWhereInput!]
  updateMany: [ChallengeUpdateManyWithWhereNestedInput!]
}

input ChallengeUpdateManyMutationInput {
  name: String
  description: String
  value: Int
}

input ChallengeUpdateManyWithoutCompaniesInput {
  create: [ChallengeCreateWithoutCompaniesInput!]
  delete: [ChallengeWhereUniqueInput!]
  connect: [ChallengeWhereUniqueInput!]
  set: [ChallengeWhereUniqueInput!]
  disconnect: [ChallengeWhereUniqueInput!]
  update: [ChallengeUpdateWithWhereUniqueWithoutCompaniesInput!]
  upsert: [ChallengeUpsertWithWhereUniqueWithoutCompaniesInput!]
  deleteMany: [ChallengeScalarWhereInput!]
  updateMany: [ChallengeUpdateManyWithWhereNestedInput!]
}

input ChallengeUpdateManyWithWhereNestedInput {
  where: ChallengeScalarWhereInput!
  data: ChallengeUpdateManyDataInput!
}

input ChallengeUpdateWithoutCompaniesDataInput {
  name: String
  description: String
  value: Int
}

input ChallengeUpdateWithWhereUniqueNestedInput {
  where: ChallengeWhereUniqueInput!
  data: ChallengeUpdateDataInput!
}

input ChallengeUpdateWithWhereUniqueWithoutCompaniesInput {
  where: ChallengeWhereUniqueInput!
  data: ChallengeUpdateWithoutCompaniesDataInput!
}

input ChallengeUpsertWithWhereUniqueNestedInput {
  where: ChallengeWhereUniqueInput!
  update: ChallengeUpdateDataInput!
  create: ChallengeCreateInput!
}

input ChallengeUpsertWithWhereUniqueWithoutCompaniesInput {
  where: ChallengeWhereUniqueInput!
  update: ChallengeUpdateWithoutCompaniesDataInput!
  create: ChallengeCreateWithoutCompaniesInput!
}

input ChallengeWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  value: Int
  value_not: Int
  value_in: [Int!]
  value_not_in: [Int!]
  value_lt: Int
  value_lte: Int
  value_gt: Int
  value_gte: Int
  companies_some: CompanyWhereInput
  AND: [ChallengeWhereInput!]
}

input ChallengeWhereUniqueInput {
  id: ID
}

type Company {
  id: ID!
  name: String
  type: CompanyType
  address: Address
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User!]
  emailDomains: [String!]!
  stripeCustomerId: String
  challenges(where: ChallengeWhereInput, orderBy: ChallengeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Challenge!]
  quizzes(where: QuizWhereInput, orderBy: QuizOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Quiz!]
}

type CompanyConnection {
  pageInfo: PageInfo!
  edges: [CompanyEdge]!
  aggregate: AggregateCompany!
}

input CompanyCreateemailDomainsInput {
  set: [String!]
}

input CompanyCreateInput {
  id: ID
  name: String
  type: CompanyType
  address: AddressCreateOneInput
  users: UserCreateManyWithoutCompanyInput
  emailDomains: CompanyCreateemailDomainsInput
  stripeCustomerId: String
  challenges: ChallengeCreateManyWithoutCompaniesInput
  quizzes: QuizCreateManyWithoutCompaniesInput
}

input CompanyCreateManyWithoutChallengesInput {
  create: [CompanyCreateWithoutChallengesInput!]
  connect: [CompanyWhereUniqueInput!]
}

input CompanyCreateManyWithoutQuizzesInput {
  create: [CompanyCreateWithoutQuizzesInput!]
  connect: [CompanyWhereUniqueInput!]
}

input CompanyCreateOneWithoutUsersInput {
  create: CompanyCreateWithoutUsersInput
  connect: CompanyWhereUniqueInput
}

input CompanyCreateWithoutChallengesInput {
  id: ID
  name: String
  type: CompanyType
  address: AddressCreateOneInput
  users: UserCreateManyWithoutCompanyInput
  emailDomains: CompanyCreateemailDomainsInput
  stripeCustomerId: String
  quizzes: QuizCreateManyWithoutCompaniesInput
}

input CompanyCreateWithoutQuizzesInput {
  id: ID
  name: String
  type: CompanyType
  address: AddressCreateOneInput
  users: UserCreateManyWithoutCompanyInput
  emailDomains: CompanyCreateemailDomainsInput
  stripeCustomerId: String
  challenges: ChallengeCreateManyWithoutCompaniesInput
}

input CompanyCreateWithoutUsersInput {
  id: ID
  name: String
  type: CompanyType
  address: AddressCreateOneInput
  emailDomains: CompanyCreateemailDomainsInput
  stripeCustomerId: String
  challenges: ChallengeCreateManyWithoutCompaniesInput
  quizzes: QuizCreateManyWithoutCompaniesInput
}

type CompanyEdge {
  node: Company!
  cursor: String!
}

enum CompanyOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  type_ASC
  type_DESC
  stripeCustomerId_ASC
  stripeCustomerId_DESC
}

type CompanyPreviousValues {
  id: ID!
  name: String
  type: CompanyType
  emailDomains: [String!]!
  stripeCustomerId: String
}

input CompanyScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  type: CompanyType
  type_not: CompanyType
  type_in: [CompanyType!]
  type_not_in: [CompanyType!]
  stripeCustomerId: String
  stripeCustomerId_not: String
  stripeCustomerId_in: [String!]
  stripeCustomerId_not_in: [String!]
  stripeCustomerId_lt: String
  stripeCustomerId_lte: String
  stripeCustomerId_gt: String
  stripeCustomerId_gte: String
  stripeCustomerId_contains: String
  stripeCustomerId_not_contains: String
  stripeCustomerId_starts_with: String
  stripeCustomerId_not_starts_with: String
  stripeCustomerId_ends_with: String
  stripeCustomerId_not_ends_with: String
  AND: [CompanyScalarWhereInput!]
  OR: [CompanyScalarWhereInput!]
  NOT: [CompanyScalarWhereInput!]
}

type CompanySubscriptionPayload {
  mutation: MutationType!
  node: Company
  updatedFields: [String!]
  previousValues: CompanyPreviousValues
}

input CompanySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CompanyWhereInput
  AND: [CompanySubscriptionWhereInput!]
}

enum CompanyType {
  COMPANY
  SCHOOL
  PLACE
  COWORKING
}

input CompanyUpdateemailDomainsInput {
  set: [String!]
}

input CompanyUpdateInput {
  name: String
  type: CompanyType
  address: AddressUpdateOneInput
  users: UserUpdateManyWithoutCompanyInput
  emailDomains: CompanyUpdateemailDomainsInput
  stripeCustomerId: String
  challenges: ChallengeUpdateManyWithoutCompaniesInput
  quizzes: QuizUpdateManyWithoutCompaniesInput
}

input CompanyUpdateManyDataInput {
  name: String
  type: CompanyType
  emailDomains: CompanyUpdateemailDomainsInput
  stripeCustomerId: String
}

input CompanyUpdateManyMutationInput {
  name: String
  type: CompanyType
  emailDomains: CompanyUpdateemailDomainsInput
  stripeCustomerId: String
}

input CompanyUpdateManyWithoutChallengesInput {
  create: [CompanyCreateWithoutChallengesInput!]
  delete: [CompanyWhereUniqueInput!]
  connect: [CompanyWhereUniqueInput!]
  set: [CompanyWhereUniqueInput!]
  disconnect: [CompanyWhereUniqueInput!]
  update: [CompanyUpdateWithWhereUniqueWithoutChallengesInput!]
  upsert: [CompanyUpsertWithWhereUniqueWithoutChallengesInput!]
  deleteMany: [CompanyScalarWhereInput!]
  updateMany: [CompanyUpdateManyWithWhereNestedInput!]
}

input CompanyUpdateManyWithoutQuizzesInput {
  create: [CompanyCreateWithoutQuizzesInput!]
  delete: [CompanyWhereUniqueInput!]
  connect: [CompanyWhereUniqueInput!]
  set: [CompanyWhereUniqueInput!]
  disconnect: [CompanyWhereUniqueInput!]
  update: [CompanyUpdateWithWhereUniqueWithoutQuizzesInput!]
  upsert: [CompanyUpsertWithWhereUniqueWithoutQuizzesInput!]
  deleteMany: [CompanyScalarWhereInput!]
  updateMany: [CompanyUpdateManyWithWhereNestedInput!]
}

input CompanyUpdateManyWithWhereNestedInput {
  where: CompanyScalarWhereInput!
  data: CompanyUpdateManyDataInput!
}

input CompanyUpdateOneWithoutUsersInput {
  create: CompanyCreateWithoutUsersInput
  update: CompanyUpdateWithoutUsersDataInput
  upsert: CompanyUpsertWithoutUsersInput
  delete: Boolean
  disconnect: Boolean
  connect: CompanyWhereUniqueInput
}

input CompanyUpdateWithoutChallengesDataInput {
  name: String
  type: CompanyType
  address: AddressUpdateOneInput
  users: UserUpdateManyWithoutCompanyInput
  emailDomains: CompanyUpdateemailDomainsInput
  stripeCustomerId: String
  quizzes: QuizUpdateManyWithoutCompaniesInput
}

input CompanyUpdateWithoutQuizzesDataInput {
  name: String
  type: CompanyType
  address: AddressUpdateOneInput
  users: UserUpdateManyWithoutCompanyInput
  emailDomains: CompanyUpdateemailDomainsInput
  stripeCustomerId: String
  challenges: ChallengeUpdateManyWithoutCompaniesInput
}

input CompanyUpdateWithoutUsersDataInput {
  name: String
  type: CompanyType
  address: AddressUpdateOneInput
  emailDomains: CompanyUpdateemailDomainsInput
  stripeCustomerId: String
  challenges: ChallengeUpdateManyWithoutCompaniesInput
  quizzes: QuizUpdateManyWithoutCompaniesInput
}

input CompanyUpdateWithWhereUniqueWithoutChallengesInput {
  where: CompanyWhereUniqueInput!
  data: CompanyUpdateWithoutChallengesDataInput!
}

input CompanyUpdateWithWhereUniqueWithoutQuizzesInput {
  where: CompanyWhereUniqueInput!
  data: CompanyUpdateWithoutQuizzesDataInput!
}

input CompanyUpsertWithoutUsersInput {
  update: CompanyUpdateWithoutUsersDataInput!
  create: CompanyCreateWithoutUsersInput!
}

input CompanyUpsertWithWhereUniqueWithoutChallengesInput {
  where: CompanyWhereUniqueInput!
  update: CompanyUpdateWithoutChallengesDataInput!
  create: CompanyCreateWithoutChallengesInput!
}

input CompanyUpsertWithWhereUniqueWithoutQuizzesInput {
  where: CompanyWhereUniqueInput!
  update: CompanyUpdateWithoutQuizzesDataInput!
  create: CompanyCreateWithoutQuizzesInput!
}

input CompanyWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  type: CompanyType
  type_not: CompanyType
  type_in: [CompanyType!]
  type_not_in: [CompanyType!]
  address: AddressWhereInput
  users_some: UserWhereInput
  stripeCustomerId: String
  stripeCustomerId_not: String
  stripeCustomerId_in: [String!]
  stripeCustomerId_not_in: [String!]
  stripeCustomerId_lt: String
  stripeCustomerId_lte: String
  stripeCustomerId_gt: String
  stripeCustomerId_gte: String
  stripeCustomerId_contains: String
  stripeCustomerId_not_contains: String
  stripeCustomerId_starts_with: String
  stripeCustomerId_not_starts_with: String
  stripeCustomerId_ends_with: String
  stripeCustomerId_not_ends_with: String
  challenges_some: ChallengeWhereInput
  quizzes_some: QuizWhereInput
  AND: [CompanyWhereInput!]
}

input CompanyWhereUniqueInput {
  id: ID
}

enum Day {
  MONDAY
  TUESDAY
  WEDNESDAY
  THURSDAY
  FRIDAY
  SATURDAY
  SUNDAY
}

type Hour {
  day: Day
  start: String
  end: String
}

input HourCreateInput {
  day: Day
  start: String
  end: String
}

input HourCreateManyInput {
  create: [HourCreateInput!]
}

input HourRestrictedWhereInput {
  day: Day
  day_not: Day
  day_in: [Day!]
  day_not_in: [Day!]
  start: String
  start_not: String
  start_in: [String!]
  start_not_in: [String!]
  start_lt: String
  start_lte: String
  start_gt: String
  start_gte: String
  start_contains: String
  start_not_contains: String
  start_starts_with: String
  start_not_starts_with: String
  start_ends_with: String
  start_not_ends_with: String
  end: String
  end_not: String
  end_in: [String!]
  end_not_in: [String!]
  end_lt: String
  end_lte: String
  end_gt: String
  end_gte: String
  end_contains: String
  end_not_contains: String
  end_starts_with: String
  end_not_starts_with: String
  end_ends_with: String
  end_not_ends_with: String
  AND: [HourRestrictedWhereInput!]
}

input HourScalarWhereInput {
  day: Day
  day_not: Day
  day_in: [Day!]
  day_not_in: [Day!]
  start: String
  start_not: String
  start_in: [String!]
  start_not_in: [String!]
  start_lt: String
  start_lte: String
  start_gt: String
  start_gte: String
  start_contains: String
  start_not_contains: String
  start_starts_with: String
  start_not_starts_with: String
  start_ends_with: String
  start_not_ends_with: String
  end: String
  end_not: String
  end_in: [String!]
  end_not_in: [String!]
  end_lt: String
  end_lte: String
  end_gt: String
  end_gte: String
  end_contains: String
  end_not_contains: String
  end_starts_with: String
  end_not_starts_with: String
  end_ends_with: String
  end_not_ends_with: String
  AND: [HourScalarWhereInput!]
  OR: [HourScalarWhereInput!]
  NOT: [HourScalarWhereInput!]
}

input HourUpdateManyDataInput {
  day: Day
  start: String
  end: String
}

input HourUpdateManyInput {
  create: [HourCreateInput!]
  deleteMany: [HourScalarWhereInput!]
  updateMany: [HourUpdateManyWithWhereNestedInput!]
}

input HourUpdateManyWithWhereNestedInput {
  where: HourScalarWhereInput!
  data: HourUpdateManyDataInput!
}

input HourWhereInput {
  day: Day
  day_not: Day
  day_in: [Day!]
  day_not_in: [Day!]
  start: String
  start_not: String
  start_in: [String!]
  start_not_in: [String!]
  start_lt: String
  start_lte: String
  start_gt: String
  start_gte: String
  start_contains: String
  start_not_contains: String
  start_starts_with: String
  start_not_starts_with: String
  start_ends_with: String
  start_not_ends_with: String
  end: String
  end_not: String
  end_in: [String!]
  end_not_in: [String!]
  end_lt: String
  end_lte: String
  end_gt: String
  end_gte: String
  end_contains: String
  end_not_contains: String
  end_starts_with: String
  end_not_starts_with: String
  end_ends_with: String
  end_not_ends_with: String
  AND: [HourWhereInput!]
}

scalar Long

type Mutation {
  createChallenge(data: ChallengeCreateInput!): Challenge!
  updateChallenge(data: ChallengeUpdateInput!, where: ChallengeWhereUniqueInput!): Challenge
  updateManyChallenges(data: ChallengeUpdateManyMutationInput!, where: ChallengeWhereInput): BatchPayload!
  upsertChallenge(where: ChallengeWhereUniqueInput!, create: ChallengeCreateInput!, update: ChallengeUpdateInput!): Challenge!
  deleteChallenge(where: ChallengeWhereUniqueInput!): Challenge
  deleteManyChallenges(where: ChallengeWhereInput): BatchPayload!
  createCompany(data: CompanyCreateInput!): Company!
  updateCompany(data: CompanyUpdateInput!, where: CompanyWhereUniqueInput!): Company
  updateManyCompanies(data: CompanyUpdateManyMutationInput!, where: CompanyWhereInput): BatchPayload!
  upsertCompany(where: CompanyWhereUniqueInput!, create: CompanyCreateInput!, update: CompanyUpdateInput!): Company!
  deleteCompany(where: CompanyWhereUniqueInput!): Company
  deleteManyCompanies(where: CompanyWhereInput): BatchPayload!
  createPlace(data: PlaceCreateInput!): Place!
  updatePlace(data: PlaceUpdateInput!, where: PlaceWhereUniqueInput!): Place
  updateManyPlaces(data: PlaceUpdateManyMutationInput!, where: PlaceWhereInput): BatchPayload!
  upsertPlace(where: PlaceWhereUniqueInput!, create: PlaceCreateInput!, update: PlaceUpdateInput!): Place!
  deletePlace(where: PlaceWhereUniqueInput!): Place
  deleteManyPlaces(where: PlaceWhereInput): BatchPayload!
  createQuiz(data: QuizCreateInput!): Quiz!
  updateQuiz(data: QuizUpdateInput!, where: QuizWhereUniqueInput!): Quiz
  updateManyQuizzes(data: QuizUpdateManyMutationInput!, where: QuizWhereInput): BatchPayload!
  upsertQuiz(where: QuizWhereUniqueInput!, create: QuizCreateInput!, update: QuizUpdateInput!): Quiz!
  deleteQuiz(where: QuizWhereUniqueInput!): Quiz
  deleteManyQuizzes(where: QuizWhereInput): BatchPayload!
  createTag(data: TagCreateInput!): Tag!
  updateTag(data: TagUpdateInput!, where: TagWhereUniqueInput!): Tag
  updateManyTags(data: TagUpdateManyMutationInput!, where: TagWhereInput): BatchPayload!
  upsertTag(where: TagWhereUniqueInput!, create: TagCreateInput!, update: TagUpdateInput!): Tag!
  deleteTag(where: TagWhereUniqueInput!): Tag
  deleteManyTags(where: TagWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Place {
  id: ID!
  name: String
  address: Address
  hours: [Hour!]
  category: Category
  tags(where: TagWhereInput, orderBy: TagOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Tag!]
}

type PlaceConnection {
  pageInfo: PageInfo!
  edges: [PlaceEdge]!
  aggregate: AggregatePlace!
}

input PlaceCreateInput {
  id: ID
  name: String
  address: AddressCreateOneInput
  hours: HourCreateManyInput
  category: Category
  tags: TagCreateManyInput
}

type PlaceEdge {
  node: Place!
  cursor: String!
}

enum PlaceOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  category_ASC
  category_DESC
}

type PlacePreviousValues {
  id: ID!
  name: String
  category: Category
}

type PlaceSubscriptionPayload {
  mutation: MutationType!
  node: Place
  updatedFields: [String!]
  previousValues: PlacePreviousValues
}

input PlaceSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PlaceWhereInput
  AND: [PlaceSubscriptionWhereInput!]
}

input PlaceUpdateInput {
  name: String
  address: AddressUpdateOneInput
  hours: HourUpdateManyInput
  category: Category
  tags: TagUpdateManyInput
}

input PlaceUpdateManyMutationInput {
  name: String
  category: Category
}

input PlaceWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  address: AddressWhereInput
  hours_some: HourWhereInput
  hours_every: HourRestrictedWhereInput
  hours_none: HourRestrictedWhereInput
  category: Category
  category_not: Category
  category_in: [Category!]
  category_not_in: [Category!]
  tags_some: TagWhereInput
  AND: [PlaceWhereInput!]
}

input PlaceWhereUniqueInput {
  id: ID
}

type Query {
  challenge(where: ChallengeWhereUniqueInput!): Challenge
  challenges(where: ChallengeWhereInput, orderBy: ChallengeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Challenge]!
  challengesConnection(where: ChallengeWhereInput, orderBy: ChallengeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ChallengeConnection!
  company(where: CompanyWhereUniqueInput!): Company
  companies(where: CompanyWhereInput, orderBy: CompanyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Company]!
  companiesConnection(where: CompanyWhereInput, orderBy: CompanyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CompanyConnection!
  place(where: PlaceWhereUniqueInput!): Place
  places(where: PlaceWhereInput, orderBy: PlaceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Place]!
  placesConnection(where: PlaceWhereInput, orderBy: PlaceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PlaceConnection!
  quiz(where: QuizWhereUniqueInput!): Quiz
  quizzes(where: QuizWhereInput, orderBy: QuizOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Quiz]!
  quizzesConnection(where: QuizWhereInput, orderBy: QuizOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): QuizConnection!
  tag(where: TagWhereUniqueInput!): Tag
  tags(where: TagWhereInput, orderBy: TagOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Tag]!
  tagsConnection(where: TagWhereInput, orderBy: TagOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TagConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  node(id: ID!): Node
}

type Quiz {
  id: ID!
  name: String!
  question: String!
  choices: [String!]!
  answer: String!
  value: Int!
  companies(where: CompanyWhereInput, orderBy: CompanyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Company!]
}

type QuizConnection {
  pageInfo: PageInfo!
  edges: [QuizEdge]!
  aggregate: AggregateQuiz!
}

input QuizCreatechoicesInput {
  set: [String!]
}

input QuizCreateInput {
  id: ID
  name: String!
  question: String!
  choices: QuizCreatechoicesInput
  answer: String!
  value: Int!
  companies: CompanyCreateManyWithoutQuizzesInput
}

input QuizCreateManyInput {
  create: [QuizCreateInput!]
  connect: [QuizWhereUniqueInput!]
}

input QuizCreateManyWithoutCompaniesInput {
  create: [QuizCreateWithoutCompaniesInput!]
  connect: [QuizWhereUniqueInput!]
}

input QuizCreateWithoutCompaniesInput {
  id: ID
  name: String!
  question: String!
  choices: QuizCreatechoicesInput
  answer: String!
  value: Int!
}

type QuizEdge {
  node: Quiz!
  cursor: String!
}

enum QuizOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  question_ASC
  question_DESC
  answer_ASC
  answer_DESC
  value_ASC
  value_DESC
}

type QuizPreviousValues {
  id: ID!
  name: String!
  question: String!
  choices: [String!]!
  answer: String!
  value: Int!
}

input QuizScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  question: String
  question_not: String
  question_in: [String!]
  question_not_in: [String!]
  question_lt: String
  question_lte: String
  question_gt: String
  question_gte: String
  question_contains: String
  question_not_contains: String
  question_starts_with: String
  question_not_starts_with: String
  question_ends_with: String
  question_not_ends_with: String
  answer: String
  answer_not: String
  answer_in: [String!]
  answer_not_in: [String!]
  answer_lt: String
  answer_lte: String
  answer_gt: String
  answer_gte: String
  answer_contains: String
  answer_not_contains: String
  answer_starts_with: String
  answer_not_starts_with: String
  answer_ends_with: String
  answer_not_ends_with: String
  value: Int
  value_not: Int
  value_in: [Int!]
  value_not_in: [Int!]
  value_lt: Int
  value_lte: Int
  value_gt: Int
  value_gte: Int
  AND: [QuizScalarWhereInput!]
  OR: [QuizScalarWhereInput!]
  NOT: [QuizScalarWhereInput!]
}

type QuizSubscriptionPayload {
  mutation: MutationType!
  node: Quiz
  updatedFields: [String!]
  previousValues: QuizPreviousValues
}

input QuizSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: QuizWhereInput
  AND: [QuizSubscriptionWhereInput!]
}

input QuizUpdatechoicesInput {
  set: [String!]
}

input QuizUpdateDataInput {
  name: String
  question: String
  choices: QuizUpdatechoicesInput
  answer: String
  value: Int
  companies: CompanyUpdateManyWithoutQuizzesInput
}

input QuizUpdateInput {
  name: String
  question: String
  choices: QuizUpdatechoicesInput
  answer: String
  value: Int
  companies: CompanyUpdateManyWithoutQuizzesInput
}

input QuizUpdateManyDataInput {
  name: String
  question: String
  choices: QuizUpdatechoicesInput
  answer: String
  value: Int
}

input QuizUpdateManyInput {
  create: [QuizCreateInput!]
  update: [QuizUpdateWithWhereUniqueNestedInput!]
  upsert: [QuizUpsertWithWhereUniqueNestedInput!]
  delete: [QuizWhereUniqueInput!]
  connect: [QuizWhereUniqueInput!]
  set: [QuizWhereUniqueInput!]
  disconnect: [QuizWhereUniqueInput!]
  deleteMany: [QuizScalarWhereInput!]
  updateMany: [QuizUpdateManyWithWhereNestedInput!]
}

input QuizUpdateManyMutationInput {
  name: String
  question: String
  choices: QuizUpdatechoicesInput
  answer: String
  value: Int
}

input QuizUpdateManyWithoutCompaniesInput {
  create: [QuizCreateWithoutCompaniesInput!]
  delete: [QuizWhereUniqueInput!]
  connect: [QuizWhereUniqueInput!]
  set: [QuizWhereUniqueInput!]
  disconnect: [QuizWhereUniqueInput!]
  update: [QuizUpdateWithWhereUniqueWithoutCompaniesInput!]
  upsert: [QuizUpsertWithWhereUniqueWithoutCompaniesInput!]
  deleteMany: [QuizScalarWhereInput!]
  updateMany: [QuizUpdateManyWithWhereNestedInput!]
}

input QuizUpdateManyWithWhereNestedInput {
  where: QuizScalarWhereInput!
  data: QuizUpdateManyDataInput!
}

input QuizUpdateWithoutCompaniesDataInput {
  name: String
  question: String
  choices: QuizUpdatechoicesInput
  answer: String
  value: Int
}

input QuizUpdateWithWhereUniqueNestedInput {
  where: QuizWhereUniqueInput!
  data: QuizUpdateDataInput!
}

input QuizUpdateWithWhereUniqueWithoutCompaniesInput {
  where: QuizWhereUniqueInput!
  data: QuizUpdateWithoutCompaniesDataInput!
}

input QuizUpsertWithWhereUniqueNestedInput {
  where: QuizWhereUniqueInput!
  update: QuizUpdateDataInput!
  create: QuizCreateInput!
}

input QuizUpsertWithWhereUniqueWithoutCompaniesInput {
  where: QuizWhereUniqueInput!
  update: QuizUpdateWithoutCompaniesDataInput!
  create: QuizCreateWithoutCompaniesInput!
}

input QuizWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  question: String
  question_not: String
  question_in: [String!]
  question_not_in: [String!]
  question_lt: String
  question_lte: String
  question_gt: String
  question_gte: String
  question_contains: String
  question_not_contains: String
  question_starts_with: String
  question_not_starts_with: String
  question_ends_with: String
  question_not_ends_with: String
  answer: String
  answer_not: String
  answer_in: [String!]
  answer_not_in: [String!]
  answer_lt: String
  answer_lte: String
  answer_gt: String
  answer_gte: String
  answer_contains: String
  answer_not_contains: String
  answer_starts_with: String
  answer_not_starts_with: String
  answer_ends_with: String
  answer_not_ends_with: String
  value: Int
  value_not: Int
  value_in: [Int!]
  value_not_in: [Int!]
  value_lt: Int
  value_lte: Int
  value_gt: Int
  value_gte: Int
  companies_some: CompanyWhereInput
  AND: [QuizWhereInput!]
}

input QuizWhereUniqueInput {
  id: ID
}

enum Role {
  SUPER_ADMIN
  ADMIN
  MODERATOR
  USER
}

type Subscription {
  challenge(where: ChallengeSubscriptionWhereInput): ChallengeSubscriptionPayload
  company(where: CompanySubscriptionWhereInput): CompanySubscriptionPayload
  place(where: PlaceSubscriptionWhereInput): PlaceSubscriptionPayload
  quiz(where: QuizSubscriptionWhereInput): QuizSubscriptionPayload
  tag(where: TagSubscriptionWhereInput): TagSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
}

type Tag {
  id: ID!
  label: String!
  children(where: TagWhereInput, orderBy: TagOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Tag!]
  root: Boolean
  leaf: Boolean
  category: Category!
}

type TagConnection {
  pageInfo: PageInfo!
  edges: [TagEdge]!
  aggregate: AggregateTag!
}

input TagCreateInput {
  id: ID
  label: String!
  children: TagCreateManyInput
  root: Boolean
  leaf: Boolean
  category: Category!
}

input TagCreateManyInput {
  create: [TagCreateInput!]
  connect: [TagWhereUniqueInput!]
}

type TagEdge {
  node: Tag!
  cursor: String!
}

enum TagOrderByInput {
  id_ASC
  id_DESC
  label_ASC
  label_DESC
  root_ASC
  root_DESC
  leaf_ASC
  leaf_DESC
  category_ASC
  category_DESC
}

type TagPreviousValues {
  id: ID!
  label: String!
  root: Boolean
  leaf: Boolean
  category: Category!
}

input TagScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  label: String
  label_not: String
  label_in: [String!]
  label_not_in: [String!]
  label_lt: String
  label_lte: String
  label_gt: String
  label_gte: String
  label_contains: String
  label_not_contains: String
  label_starts_with: String
  label_not_starts_with: String
  label_ends_with: String
  label_not_ends_with: String
  root: Boolean
  root_not: Boolean
  leaf: Boolean
  leaf_not: Boolean
  category: Category
  category_not: Category
  category_in: [Category!]
  category_not_in: [Category!]
  AND: [TagScalarWhereInput!]
  OR: [TagScalarWhereInput!]
  NOT: [TagScalarWhereInput!]
}

type TagSubscriptionPayload {
  mutation: MutationType!
  node: Tag
  updatedFields: [String!]
  previousValues: TagPreviousValues
}

input TagSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: TagWhereInput
  AND: [TagSubscriptionWhereInput!]
}

input TagUpdateDataInput {
  label: String
  children: TagUpdateManyInput
  root: Boolean
  leaf: Boolean
  category: Category
}

input TagUpdateInput {
  label: String
  children: TagUpdateManyInput
  root: Boolean
  leaf: Boolean
  category: Category
}

input TagUpdateManyDataInput {
  label: String
  root: Boolean
  leaf: Boolean
  category: Category
}

input TagUpdateManyInput {
  create: [TagCreateInput!]
  update: [TagUpdateWithWhereUniqueNestedInput!]
  upsert: [TagUpsertWithWhereUniqueNestedInput!]
  delete: [TagWhereUniqueInput!]
  connect: [TagWhereUniqueInput!]
  set: [TagWhereUniqueInput!]
  disconnect: [TagWhereUniqueInput!]
  deleteMany: [TagScalarWhereInput!]
  updateMany: [TagUpdateManyWithWhereNestedInput!]
}

input TagUpdateManyMutationInput {
  label: String
  root: Boolean
  leaf: Boolean
  category: Category
}

input TagUpdateManyWithWhereNestedInput {
  where: TagScalarWhereInput!
  data: TagUpdateManyDataInput!
}

input TagUpdateWithWhereUniqueNestedInput {
  where: TagWhereUniqueInput!
  data: TagUpdateDataInput!
}

input TagUpsertWithWhereUniqueNestedInput {
  where: TagWhereUniqueInput!
  update: TagUpdateDataInput!
  create: TagCreateInput!
}

input TagWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  label: String
  label_not: String
  label_in: [String!]
  label_not_in: [String!]
  label_lt: String
  label_lte: String
  label_gt: String
  label_gte: String
  label_contains: String
  label_not_contains: String
  label_starts_with: String
  label_not_starts_with: String
  label_ends_with: String
  label_not_ends_with: String
  children_some: TagWhereInput
  root: Boolean
  root_not: Boolean
  leaf: Boolean
  leaf_not: Boolean
  category: Category
  category_not: Category
  category_in: [Category!]
  category_not_in: [Category!]
  AND: [TagWhereInput!]
}

input TagWhereUniqueInput {
  id: ID
}

type User {
  id: ID!
  firstName: String
  lastName: String
  email: String
  phone: String
  password: String
  role: Role
  isRepresentative: Boolean
  company: Company
  points: Int
  validatedChallenges(where: ChallengeWhereInput, orderBy: ChallengeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Challenge!]
  validatedQuizzes(where: QuizWhereInput, orderBy: QuizOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Quiz!]
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  id: ID
  firstName: String
  lastName: String
  email: String
  phone: String
  password: String
  role: Role
  isRepresentative: Boolean
  company: CompanyCreateOneWithoutUsersInput
  points: Int
  validatedChallenges: ChallengeCreateManyInput
  validatedQuizzes: QuizCreateManyInput
}

input UserCreateManyWithoutCompanyInput {
  create: [UserCreateWithoutCompanyInput!]
  connect: [UserWhereUniqueInput!]
}

input UserCreateWithoutCompanyInput {
  id: ID
  firstName: String
  lastName: String
  email: String
  phone: String
  password: String
  role: Role
  isRepresentative: Boolean
  points: Int
  validatedChallenges: ChallengeCreateManyInput
  validatedQuizzes: QuizCreateManyInput
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  firstName_ASC
  firstName_DESC
  lastName_ASC
  lastName_DESC
  email_ASC
  email_DESC
  phone_ASC
  phone_DESC
  password_ASC
  password_DESC
  role_ASC
  role_DESC
  isRepresentative_ASC
  isRepresentative_DESC
  points_ASC
  points_DESC
}

type UserPreviousValues {
  id: ID!
  firstName: String
  lastName: String
  email: String
  phone: String
  password: String
  role: Role
  isRepresentative: Boolean
  points: Int
}

input UserScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  firstName: String
  firstName_not: String
  firstName_in: [String!]
  firstName_not_in: [String!]
  firstName_lt: String
  firstName_lte: String
  firstName_gt: String
  firstName_gte: String
  firstName_contains: String
  firstName_not_contains: String
  firstName_starts_with: String
  firstName_not_starts_with: String
  firstName_ends_with: String
  firstName_not_ends_with: String
  lastName: String
  lastName_not: String
  lastName_in: [String!]
  lastName_not_in: [String!]
  lastName_lt: String
  lastName_lte: String
  lastName_gt: String
  lastName_gte: String
  lastName_contains: String
  lastName_not_contains: String
  lastName_starts_with: String
  lastName_not_starts_with: String
  lastName_ends_with: String
  lastName_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  phone: String
  phone_not: String
  phone_in: [String!]
  phone_not_in: [String!]
  phone_lt: String
  phone_lte: String
  phone_gt: String
  phone_gte: String
  phone_contains: String
  phone_not_contains: String
  phone_starts_with: String
  phone_not_starts_with: String
  phone_ends_with: String
  phone_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  role: Role
  role_not: Role
  role_in: [Role!]
  role_not_in: [Role!]
  isRepresentative: Boolean
  isRepresentative_not: Boolean
  points: Int
  points_not: Int
  points_in: [Int!]
  points_not_in: [Int!]
  points_lt: Int
  points_lte: Int
  points_gt: Int
  points_gte: Int
  AND: [UserScalarWhereInput!]
  OR: [UserScalarWhereInput!]
  NOT: [UserScalarWhereInput!]
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
}

input UserUpdateInput {
  firstName: String
  lastName: String
  email: String
  phone: String
  password: String
  role: Role
  isRepresentative: Boolean
  company: CompanyUpdateOneWithoutUsersInput
  points: Int
  validatedChallenges: ChallengeUpdateManyInput
  validatedQuizzes: QuizUpdateManyInput
}

input UserUpdateManyDataInput {
  firstName: String
  lastName: String
  email: String
  phone: String
  password: String
  role: Role
  isRepresentative: Boolean
  points: Int
}

input UserUpdateManyMutationInput {
  firstName: String
  lastName: String
  email: String
  phone: String
  password: String
  role: Role
  isRepresentative: Boolean
  points: Int
}

input UserUpdateManyWithoutCompanyInput {
  create: [UserCreateWithoutCompanyInput!]
  delete: [UserWhereUniqueInput!]
  connect: [UserWhereUniqueInput!]
  set: [UserWhereUniqueInput!]
  disconnect: [UserWhereUniqueInput!]
  update: [UserUpdateWithWhereUniqueWithoutCompanyInput!]
  upsert: [UserUpsertWithWhereUniqueWithoutCompanyInput!]
  deleteMany: [UserScalarWhereInput!]
  updateMany: [UserUpdateManyWithWhereNestedInput!]
}

input UserUpdateManyWithWhereNestedInput {
  where: UserScalarWhereInput!
  data: UserUpdateManyDataInput!
}

input UserUpdateWithoutCompanyDataInput {
  firstName: String
  lastName: String
  email: String
  phone: String
  password: String
  role: Role
  isRepresentative: Boolean
  points: Int
  validatedChallenges: ChallengeUpdateManyInput
  validatedQuizzes: QuizUpdateManyInput
}

input UserUpdateWithWhereUniqueWithoutCompanyInput {
  where: UserWhereUniqueInput!
  data: UserUpdateWithoutCompanyDataInput!
}

input UserUpsertWithWhereUniqueWithoutCompanyInput {
  where: UserWhereUniqueInput!
  update: UserUpdateWithoutCompanyDataInput!
  create: UserCreateWithoutCompanyInput!
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  firstName: String
  firstName_not: String
  firstName_in: [String!]
  firstName_not_in: [String!]
  firstName_lt: String
  firstName_lte: String
  firstName_gt: String
  firstName_gte: String
  firstName_contains: String
  firstName_not_contains: String
  firstName_starts_with: String
  firstName_not_starts_with: String
  firstName_ends_with: String
  firstName_not_ends_with: String
  lastName: String
  lastName_not: String
  lastName_in: [String!]
  lastName_not_in: [String!]
  lastName_lt: String
  lastName_lte: String
  lastName_gt: String
  lastName_gte: String
  lastName_contains: String
  lastName_not_contains: String
  lastName_starts_with: String
  lastName_not_starts_with: String
  lastName_ends_with: String
  lastName_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  phone: String
  phone_not: String
  phone_in: [String!]
  phone_not_in: [String!]
  phone_lt: String
  phone_lte: String
  phone_gt: String
  phone_gte: String
  phone_contains: String
  phone_not_contains: String
  phone_starts_with: String
  phone_not_starts_with: String
  phone_ends_with: String
  phone_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  role: Role
  role_not: Role
  role_in: [Role!]
  role_not_in: [Role!]
  isRepresentative: Boolean
  isRepresentative_not: Boolean
  company: CompanyWhereInput
  points: Int
  points_not: Int
  points_in: [Int!]
  points_not_in: [Int!]
  points_lt: Int
  points_lte: Int
  points_gt: Int
  points_gte: Int
  validatedChallenges_some: ChallengeWhereInput
  validatedQuizzes_some: QuizWhereInput
  AND: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
  email: String
}
`
      }
    