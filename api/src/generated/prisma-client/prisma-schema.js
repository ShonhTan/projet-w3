module.exports = {
        typeDefs: // Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

/* GraphQL */ `type Address {
  street: String
  zipCode: String
  city: String
  location: Point
}

input AddressCreateInput {
  street: String
  zipCode: String
  city: String
  location: PointCreateOneInput
}

input AddressCreateOneInput {
  create: AddressCreateInput
}

input AddressUpdateDataInput {
  street: String
  zipCode: String
  city: String
  location: PointUpdateOneInput
}

input AddressUpdateOneInput {
  create: AddressCreateInput
  update: AddressUpdateDataInput
  upsert: AddressUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
}

input AddressUpsertNestedInput {
  update: AddressUpdateDataInput!
  create: AddressCreateInput!
}

input AddressWhereInput {
  street: String
  street_not: String
  street_in: [String!]
  street_not_in: [String!]
  street_lt: String
  street_lte: String
  street_gt: String
  street_gte: String
  street_contains: String
  street_not_contains: String
  street_starts_with: String
  street_not_starts_with: String
  street_ends_with: String
  street_not_ends_with: String
  zipCode: String
  zipCode_not: String
  zipCode_in: [String!]
  zipCode_not_in: [String!]
  zipCode_lt: String
  zipCode_lte: String
  zipCode_gt: String
  zipCode_gte: String
  zipCode_contains: String
  zipCode_not_contains: String
  zipCode_starts_with: String
  zipCode_not_starts_with: String
  zipCode_ends_with: String
  zipCode_not_ends_with: String
  city: String
  city_not: String
  city_in: [String!]
  city_not_in: [String!]
  city_lt: String
  city_lte: String
  city_gt: String
  city_gte: String
  city_contains: String
  city_not_contains: String
  city_starts_with: String
  city_not_starts_with: String
  city_ends_with: String
  city_not_ends_with: String
  location: PointWhereInput
  AND: [AddressWhereInput!]
}

type AggregateArticle {
  count: Int!
}

type AggregateChallenge {
  count: Int!
}

type AggregateCompany {
  count: Int!
}

type AggregatePhoto {
  count: Int!
}

type AggregatePlace {
  count: Int!
}

type AggregateTag {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type AggregateValidatedQuiz {
  count: Int!
}

type Article {
  id: ID!
  title: String!
  content: String!
  theme: Theme!
  photo: Photo
  videoUrl: String
  quiz: Quiz
  date: String!
}

type ArticleConnection {
  pageInfo: PageInfo!
  edges: [ArticleEdge]!
  aggregate: AggregateArticle!
}

input ArticleCreateInput {
  id: ID
  title: String!
  content: String!
  theme: Theme!
  photo: PhotoCreateOneInput
  videoUrl: String
  quiz: QuizCreateOneInput
  date: String!
}

input ArticleCreateOneInput {
  create: ArticleCreateInput
  connect: ArticleWhereUniqueInput
}

type ArticleEdge {
  node: Article!
  cursor: String!
}

enum ArticleOrderByInput {
  id_ASC
  id_DESC
  title_ASC
  title_DESC
  content_ASC
  content_DESC
  theme_ASC
  theme_DESC
  videoUrl_ASC
  videoUrl_DESC
  date_ASC
  date_DESC
}

type ArticlePreviousValues {
  id: ID!
  title: String!
  content: String!
  theme: Theme!
  videoUrl: String
  date: String!
}

type ArticleSubscriptionPayload {
  mutation: MutationType!
  node: Article
  updatedFields: [String!]
  previousValues: ArticlePreviousValues
}

input ArticleSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ArticleWhereInput
  AND: [ArticleSubscriptionWhereInput!]
}

input ArticleUpdateDataInput {
  title: String
  content: String
  theme: Theme
  photo: PhotoUpdateOneInput
  videoUrl: String
  quiz: QuizUpdateOneInput
  date: String
}

input ArticleUpdateInput {
  title: String
  content: String
  theme: Theme
  photo: PhotoUpdateOneInput
  videoUrl: String
  quiz: QuizUpdateOneInput
  date: String
}

input ArticleUpdateManyMutationInput {
  title: String
  content: String
  theme: Theme
  videoUrl: String
  date: String
}

input ArticleUpdateOneRequiredInput {
  create: ArticleCreateInput
  update: ArticleUpdateDataInput
  upsert: ArticleUpsertNestedInput
  connect: ArticleWhereUniqueInput
}

input ArticleUpsertNestedInput {
  update: ArticleUpdateDataInput!
  create: ArticleCreateInput!
}

input ArticleWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  content: String
  content_not: String
  content_in: [String!]
  content_not_in: [String!]
  content_lt: String
  content_lte: String
  content_gt: String
  content_gte: String
  content_contains: String
  content_not_contains: String
  content_starts_with: String
  content_not_starts_with: String
  content_ends_with: String
  content_not_ends_with: String
  theme: Theme
  theme_not: Theme
  theme_in: [Theme!]
  theme_not_in: [Theme!]
  photo: PhotoWhereInput
  videoUrl: String
  videoUrl_not: String
  videoUrl_in: [String!]
  videoUrl_not_in: [String!]
  videoUrl_lt: String
  videoUrl_lte: String
  videoUrl_gt: String
  videoUrl_gte: String
  videoUrl_contains: String
  videoUrl_not_contains: String
  videoUrl_starts_with: String
  videoUrl_not_starts_with: String
  videoUrl_ends_with: String
  videoUrl_not_ends_with: String
  quiz: QuizWhereInput
  date: String
  date_not: String
  date_in: [String!]
  date_not_in: [String!]
  date_lt: String
  date_lte: String
  date_gt: String
  date_gte: String
  date_contains: String
  date_not_contains: String
  date_starts_with: String
  date_not_starts_with: String
  date_ends_with: String
  date_not_ends_with: String
  AND: [ArticleWhereInput!]
}

input ArticleWhereUniqueInput {
  id: ID
}

type BatchPayload {
  count: Long!
}

enum Category {
  FOOD
  SHOP
  ACTIVITY
}

type Challenge {
  id: ID!
  name: String!
  description: String!
  theme: Theme!
  value: Int!
  companies(where: CompanyWhereInput, orderBy: CompanyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Company!]
}

type ChallengeConnection {
  pageInfo: PageInfo!
  edges: [ChallengeEdge]!
  aggregate: AggregateChallenge!
}

input ChallengeCreateInput {
  id: ID
  name: String!
  description: String!
  theme: Theme!
  value: Int!
  companies: CompanyCreateManyWithoutChallengesInput
}

input ChallengeCreateManyInput {
  create: [ChallengeCreateInput!]
  connect: [ChallengeWhereUniqueInput!]
}

input ChallengeCreateManyWithoutCompaniesInput {
  create: [ChallengeCreateWithoutCompaniesInput!]
  connect: [ChallengeWhereUniqueInput!]
}

input ChallengeCreateWithoutCompaniesInput {
  id: ID
  name: String!
  description: String!
  theme: Theme!
  value: Int!
}

type ChallengeEdge {
  node: Challenge!
  cursor: String!
}

enum ChallengeOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  description_ASC
  description_DESC
  theme_ASC
  theme_DESC
  value_ASC
  value_DESC
}

type ChallengePreviousValues {
  id: ID!
  name: String!
  description: String!
  theme: Theme!
  value: Int!
}

input ChallengeScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  theme: Theme
  theme_not: Theme
  theme_in: [Theme!]
  theme_not_in: [Theme!]
  value: Int
  value_not: Int
  value_in: [Int!]
  value_not_in: [Int!]
  value_lt: Int
  value_lte: Int
  value_gt: Int
  value_gte: Int
  AND: [ChallengeScalarWhereInput!]
  OR: [ChallengeScalarWhereInput!]
  NOT: [ChallengeScalarWhereInput!]
}

type ChallengeSubscriptionPayload {
  mutation: MutationType!
  node: Challenge
  updatedFields: [String!]
  previousValues: ChallengePreviousValues
}

input ChallengeSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ChallengeWhereInput
  AND: [ChallengeSubscriptionWhereInput!]
}

input ChallengeUpdateDataInput {
  name: String
  description: String
  theme: Theme
  value: Int
  companies: CompanyUpdateManyWithoutChallengesInput
}

input ChallengeUpdateInput {
  name: String
  description: String
  theme: Theme
  value: Int
  companies: CompanyUpdateManyWithoutChallengesInput
}

input ChallengeUpdateManyDataInput {
  name: String
  description: String
  theme: Theme
  value: Int
}

input ChallengeUpdateManyInput {
  create: [ChallengeCreateInput!]
  update: [ChallengeUpdateWithWhereUniqueNestedInput!]
  upsert: [ChallengeUpsertWithWhereUniqueNestedInput!]
  delete: [ChallengeWhereUniqueInput!]
  connect: [ChallengeWhereUniqueInput!]
  set: [ChallengeWhereUniqueInput!]
  disconnect: [ChallengeWhereUniqueInput!]
  deleteMany: [ChallengeScalarWhereInput!]
  updateMany: [ChallengeUpdateManyWithWhereNestedInput!]
}

input ChallengeUpdateManyMutationInput {
  name: String
  description: String
  theme: Theme
  value: Int
}

input ChallengeUpdateManyWithoutCompaniesInput {
  create: [ChallengeCreateWithoutCompaniesInput!]
  delete: [ChallengeWhereUniqueInput!]
  connect: [ChallengeWhereUniqueInput!]
  set: [ChallengeWhereUniqueInput!]
  disconnect: [ChallengeWhereUniqueInput!]
  update: [ChallengeUpdateWithWhereUniqueWithoutCompaniesInput!]
  upsert: [ChallengeUpsertWithWhereUniqueWithoutCompaniesInput!]
  deleteMany: [ChallengeScalarWhereInput!]
  updateMany: [ChallengeUpdateManyWithWhereNestedInput!]
}

input ChallengeUpdateManyWithWhereNestedInput {
  where: ChallengeScalarWhereInput!
  data: ChallengeUpdateManyDataInput!
}

input ChallengeUpdateWithoutCompaniesDataInput {
  name: String
  description: String
  theme: Theme
  value: Int
}

input ChallengeUpdateWithWhereUniqueNestedInput {
  where: ChallengeWhereUniqueInput!
  data: ChallengeUpdateDataInput!
}

input ChallengeUpdateWithWhereUniqueWithoutCompaniesInput {
  where: ChallengeWhereUniqueInput!
  data: ChallengeUpdateWithoutCompaniesDataInput!
}

input ChallengeUpsertWithWhereUniqueNestedInput {
  where: ChallengeWhereUniqueInput!
  update: ChallengeUpdateDataInput!
  create: ChallengeCreateInput!
}

input ChallengeUpsertWithWhereUniqueWithoutCompaniesInput {
  where: ChallengeWhereUniqueInput!
  update: ChallengeUpdateWithoutCompaniesDataInput!
  create: ChallengeCreateWithoutCompaniesInput!
}

input ChallengeWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  theme: Theme
  theme_not: Theme
  theme_in: [Theme!]
  theme_not_in: [Theme!]
  value: Int
  value_not: Int
  value_in: [Int!]
  value_not_in: [Int!]
  value_lt: Int
  value_lte: Int
  value_gt: Int
  value_gte: Int
  companies_some: CompanyWhereInput
  AND: [ChallengeWhereInput!]
}

input ChallengeWhereUniqueInput {
  id: ID
}

type Company {
  id: ID!
  name: String
  type: CompanyType
  address: Address
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User!]
  emailDomains: [String!]!
  stripeCustomerId: String
  challenges(where: ChallengeWhereInput, orderBy: ChallengeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Challenge!]
}

type CompanyConnection {
  pageInfo: PageInfo!
  edges: [CompanyEdge]!
  aggregate: AggregateCompany!
}

input CompanyCreateemailDomainsInput {
  set: [String!]
}

input CompanyCreateInput {
  id: ID
  name: String
  type: CompanyType
  address: AddressCreateOneInput
  users: UserCreateManyWithoutCompanyInput
  emailDomains: CompanyCreateemailDomainsInput
  stripeCustomerId: String
  challenges: ChallengeCreateManyWithoutCompaniesInput
}

input CompanyCreateManyWithoutChallengesInput {
  create: [CompanyCreateWithoutChallengesInput!]
  connect: [CompanyWhereUniqueInput!]
}

input CompanyCreateOneWithoutUsersInput {
  create: CompanyCreateWithoutUsersInput
  connect: CompanyWhereUniqueInput
}

input CompanyCreateWithoutChallengesInput {
  id: ID
  name: String
  type: CompanyType
  address: AddressCreateOneInput
  users: UserCreateManyWithoutCompanyInput
  emailDomains: CompanyCreateemailDomainsInput
  stripeCustomerId: String
}

input CompanyCreateWithoutUsersInput {
  id: ID
  name: String
  type: CompanyType
  address: AddressCreateOneInput
  emailDomains: CompanyCreateemailDomainsInput
  stripeCustomerId: String
  challenges: ChallengeCreateManyWithoutCompaniesInput
}

type CompanyEdge {
  node: Company!
  cursor: String!
}

enum CompanyOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  type_ASC
  type_DESC
  stripeCustomerId_ASC
  stripeCustomerId_DESC
}

type CompanyPreviousValues {
  id: ID!
  name: String
  type: CompanyType
  emailDomains: [String!]!
  stripeCustomerId: String
}

input CompanyScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  type: CompanyType
  type_not: CompanyType
  type_in: [CompanyType!]
  type_not_in: [CompanyType!]
  stripeCustomerId: String
  stripeCustomerId_not: String
  stripeCustomerId_in: [String!]
  stripeCustomerId_not_in: [String!]
  stripeCustomerId_lt: String
  stripeCustomerId_lte: String
  stripeCustomerId_gt: String
  stripeCustomerId_gte: String
  stripeCustomerId_contains: String
  stripeCustomerId_not_contains: String
  stripeCustomerId_starts_with: String
  stripeCustomerId_not_starts_with: String
  stripeCustomerId_ends_with: String
  stripeCustomerId_not_ends_with: String
  AND: [CompanyScalarWhereInput!]
  OR: [CompanyScalarWhereInput!]
  NOT: [CompanyScalarWhereInput!]
}

type CompanySubscriptionPayload {
  mutation: MutationType!
  node: Company
  updatedFields: [String!]
  previousValues: CompanyPreviousValues
}

input CompanySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CompanyWhereInput
  AND: [CompanySubscriptionWhereInput!]
}

enum CompanyType {
  COMPANY
  SCHOOL
  PLACE
  COWORKING
}

input CompanyUpdateemailDomainsInput {
  set: [String!]
}

input CompanyUpdateInput {
  name: String
  type: CompanyType
  address: AddressUpdateOneInput
  users: UserUpdateManyWithoutCompanyInput
  emailDomains: CompanyUpdateemailDomainsInput
  stripeCustomerId: String
  challenges: ChallengeUpdateManyWithoutCompaniesInput
}

input CompanyUpdateManyDataInput {
  name: String
  type: CompanyType
  emailDomains: CompanyUpdateemailDomainsInput
  stripeCustomerId: String
}

input CompanyUpdateManyMutationInput {
  name: String
  type: CompanyType
  emailDomains: CompanyUpdateemailDomainsInput
  stripeCustomerId: String
}

input CompanyUpdateManyWithoutChallengesInput {
  create: [CompanyCreateWithoutChallengesInput!]
  delete: [CompanyWhereUniqueInput!]
  connect: [CompanyWhereUniqueInput!]
  set: [CompanyWhereUniqueInput!]
  disconnect: [CompanyWhereUniqueInput!]
  update: [CompanyUpdateWithWhereUniqueWithoutChallengesInput!]
  upsert: [CompanyUpsertWithWhereUniqueWithoutChallengesInput!]
  deleteMany: [CompanyScalarWhereInput!]
  updateMany: [CompanyUpdateManyWithWhereNestedInput!]
}

input CompanyUpdateManyWithWhereNestedInput {
  where: CompanyScalarWhereInput!
  data: CompanyUpdateManyDataInput!
}

input CompanyUpdateOneWithoutUsersInput {
  create: CompanyCreateWithoutUsersInput
  update: CompanyUpdateWithoutUsersDataInput
  upsert: CompanyUpsertWithoutUsersInput
  delete: Boolean
  disconnect: Boolean
  connect: CompanyWhereUniqueInput
}

input CompanyUpdateWithoutChallengesDataInput {
  name: String
  type: CompanyType
  address: AddressUpdateOneInput
  users: UserUpdateManyWithoutCompanyInput
  emailDomains: CompanyUpdateemailDomainsInput
  stripeCustomerId: String
}

input CompanyUpdateWithoutUsersDataInput {
  name: String
  type: CompanyType
  address: AddressUpdateOneInput
  emailDomains: CompanyUpdateemailDomainsInput
  stripeCustomerId: String
  challenges: ChallengeUpdateManyWithoutCompaniesInput
}

input CompanyUpdateWithWhereUniqueWithoutChallengesInput {
  where: CompanyWhereUniqueInput!
  data: CompanyUpdateWithoutChallengesDataInput!
}

input CompanyUpsertWithoutUsersInput {
  update: CompanyUpdateWithoutUsersDataInput!
  create: CompanyCreateWithoutUsersInput!
}

input CompanyUpsertWithWhereUniqueWithoutChallengesInput {
  where: CompanyWhereUniqueInput!
  update: CompanyUpdateWithoutChallengesDataInput!
  create: CompanyCreateWithoutChallengesInput!
}

input CompanyWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  type: CompanyType
  type_not: CompanyType
  type_in: [CompanyType!]
  type_not_in: [CompanyType!]
  address: AddressWhereInput
  users_some: UserWhereInput
  stripeCustomerId: String
  stripeCustomerId_not: String
  stripeCustomerId_in: [String!]
  stripeCustomerId_not_in: [String!]
  stripeCustomerId_lt: String
  stripeCustomerId_lte: String
  stripeCustomerId_gt: String
  stripeCustomerId_gte: String
  stripeCustomerId_contains: String
  stripeCustomerId_not_contains: String
  stripeCustomerId_starts_with: String
  stripeCustomerId_not_starts_with: String
  stripeCustomerId_ends_with: String
  stripeCustomerId_not_ends_with: String
  challenges_some: ChallengeWhereInput
  AND: [CompanyWhereInput!]
}

input CompanyWhereUniqueInput {
  id: ID
}

enum Day {
  MONDAY
  TUESDAY
  WEDNESDAY
  THURSDAY
  FRIDAY
  SATURDAY
  SUNDAY
}

type Hour {
  day: Day
  start: String
  end: String
}

input HourCreateInput {
  day: Day
  start: String
  end: String
}

input HourCreateManyInput {
  create: [HourCreateInput!]
}

input HourRestrictedWhereInput {
  day: Day
  day_not: Day
  day_in: [Day!]
  day_not_in: [Day!]
  start: String
  start_not: String
  start_in: [String!]
  start_not_in: [String!]
  start_lt: String
  start_lte: String
  start_gt: String
  start_gte: String
  start_contains: String
  start_not_contains: String
  start_starts_with: String
  start_not_starts_with: String
  start_ends_with: String
  start_not_ends_with: String
  end: String
  end_not: String
  end_in: [String!]
  end_not_in: [String!]
  end_lt: String
  end_lte: String
  end_gt: String
  end_gte: String
  end_contains: String
  end_not_contains: String
  end_starts_with: String
  end_not_starts_with: String
  end_ends_with: String
  end_not_ends_with: String
  AND: [HourRestrictedWhereInput!]
}

input HourScalarWhereInput {
  day: Day
  day_not: Day
  day_in: [Day!]
  day_not_in: [Day!]
  start: String
  start_not: String
  start_in: [String!]
  start_not_in: [String!]
  start_lt: String
  start_lte: String
  start_gt: String
  start_gte: String
  start_contains: String
  start_not_contains: String
  start_starts_with: String
  start_not_starts_with: String
  start_ends_with: String
  start_not_ends_with: String
  end: String
  end_not: String
  end_in: [String!]
  end_not_in: [String!]
  end_lt: String
  end_lte: String
  end_gt: String
  end_gte: String
  end_contains: String
  end_not_contains: String
  end_starts_with: String
  end_not_starts_with: String
  end_ends_with: String
  end_not_ends_with: String
  AND: [HourScalarWhereInput!]
  OR: [HourScalarWhereInput!]
  NOT: [HourScalarWhereInput!]
}

input HourUpdateManyDataInput {
  day: Day
  start: String
  end: String
}

input HourUpdateManyInput {
  create: [HourCreateInput!]
  deleteMany: [HourScalarWhereInput!]
  updateMany: [HourUpdateManyWithWhereNestedInput!]
}

input HourUpdateManyWithWhereNestedInput {
  where: HourScalarWhereInput!
  data: HourUpdateManyDataInput!
}

input HourWhereInput {
  day: Day
  day_not: Day
  day_in: [Day!]
  day_not_in: [Day!]
  start: String
  start_not: String
  start_in: [String!]
  start_not_in: [String!]
  start_lt: String
  start_lte: String
  start_gt: String
  start_gte: String
  start_contains: String
  start_not_contains: String
  start_starts_with: String
  start_not_starts_with: String
  start_ends_with: String
  start_not_ends_with: String
  end: String
  end_not: String
  end_in: [String!]
  end_not_in: [String!]
  end_lt: String
  end_lte: String
  end_gt: String
  end_gte: String
  end_contains: String
  end_not_contains: String
  end_starts_with: String
  end_not_starts_with: String
  end_ends_with: String
  end_not_ends_with: String
  AND: [HourWhereInput!]
}

scalar Long

type Mutation {
  createArticle(data: ArticleCreateInput!): Article!
  updateArticle(data: ArticleUpdateInput!, where: ArticleWhereUniqueInput!): Article
  updateManyArticles(data: ArticleUpdateManyMutationInput!, where: ArticleWhereInput): BatchPayload!
  upsertArticle(where: ArticleWhereUniqueInput!, create: ArticleCreateInput!, update: ArticleUpdateInput!): Article!
  deleteArticle(where: ArticleWhereUniqueInput!): Article
  deleteManyArticles(where: ArticleWhereInput): BatchPayload!
  createChallenge(data: ChallengeCreateInput!): Challenge!
  updateChallenge(data: ChallengeUpdateInput!, where: ChallengeWhereUniqueInput!): Challenge
  updateManyChallenges(data: ChallengeUpdateManyMutationInput!, where: ChallengeWhereInput): BatchPayload!
  upsertChallenge(where: ChallengeWhereUniqueInput!, create: ChallengeCreateInput!, update: ChallengeUpdateInput!): Challenge!
  deleteChallenge(where: ChallengeWhereUniqueInput!): Challenge
  deleteManyChallenges(where: ChallengeWhereInput): BatchPayload!
  createCompany(data: CompanyCreateInput!): Company!
  updateCompany(data: CompanyUpdateInput!, where: CompanyWhereUniqueInput!): Company
  updateManyCompanies(data: CompanyUpdateManyMutationInput!, where: CompanyWhereInput): BatchPayload!
  upsertCompany(where: CompanyWhereUniqueInput!, create: CompanyCreateInput!, update: CompanyUpdateInput!): Company!
  deleteCompany(where: CompanyWhereUniqueInput!): Company
  deleteManyCompanies(where: CompanyWhereInput): BatchPayload!
  createPhoto(data: PhotoCreateInput!): Photo!
  updatePhoto(data: PhotoUpdateInput!, where: PhotoWhereUniqueInput!): Photo
  updateManyPhotos(data: PhotoUpdateManyMutationInput!, where: PhotoWhereInput): BatchPayload!
  upsertPhoto(where: PhotoWhereUniqueInput!, create: PhotoCreateInput!, update: PhotoUpdateInput!): Photo!
  deletePhoto(where: PhotoWhereUniqueInput!): Photo
  deleteManyPhotos(where: PhotoWhereInput): BatchPayload!
  createPlace(data: PlaceCreateInput!): Place!
  updatePlace(data: PlaceUpdateInput!, where: PlaceWhereUniqueInput!): Place
  updateManyPlaces(data: PlaceUpdateManyMutationInput!, where: PlaceWhereInput): BatchPayload!
  upsertPlace(where: PlaceWhereUniqueInput!, create: PlaceCreateInput!, update: PlaceUpdateInput!): Place!
  deletePlace(where: PlaceWhereUniqueInput!): Place
  deleteManyPlaces(where: PlaceWhereInput): BatchPayload!
  createTag(data: TagCreateInput!): Tag!
  updateTag(data: TagUpdateInput!, where: TagWhereUniqueInput!): Tag
  updateManyTags(data: TagUpdateManyMutationInput!, where: TagWhereInput): BatchPayload!
  upsertTag(where: TagWhereUniqueInput!, create: TagCreateInput!, update: TagUpdateInput!): Tag!
  deleteTag(where: TagWhereUniqueInput!): Tag
  deleteManyTags(where: TagWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
  createValidatedQuiz(data: ValidatedQuizCreateInput!): ValidatedQuiz!
  updateValidatedQuiz(data: ValidatedQuizUpdateInput!, where: ValidatedQuizWhereUniqueInput!): ValidatedQuiz
  updateManyValidatedQuizzes(data: ValidatedQuizUpdateManyMutationInput!, where: ValidatedQuizWhereInput): BatchPayload!
  upsertValidatedQuiz(where: ValidatedQuizWhereUniqueInput!, create: ValidatedQuizCreateInput!, update: ValidatedQuizUpdateInput!): ValidatedQuiz!
  deleteValidatedQuiz(where: ValidatedQuizWhereUniqueInput!): ValidatedQuiz
  deleteManyValidatedQuizzes(where: ValidatedQuizWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Photo {
  id: ID!
  uri: String!
}

type PhotoConnection {
  pageInfo: PageInfo!
  edges: [PhotoEdge]!
  aggregate: AggregatePhoto!
}

input PhotoCreateInput {
  id: ID
  uri: String!
}

input PhotoCreateManyInput {
  create: [PhotoCreateInput!]
  connect: [PhotoWhereUniqueInput!]
}

input PhotoCreateOneInput {
  create: PhotoCreateInput
  connect: PhotoWhereUniqueInput
}

type PhotoEdge {
  node: Photo!
  cursor: String!
}

enum PhotoOrderByInput {
  id_ASC
  id_DESC
  uri_ASC
  uri_DESC
}

type PhotoPreviousValues {
  id: ID!
  uri: String!
}

input PhotoScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  uri: String
  uri_not: String
  uri_in: [String!]
  uri_not_in: [String!]
  uri_lt: String
  uri_lte: String
  uri_gt: String
  uri_gte: String
  uri_contains: String
  uri_not_contains: String
  uri_starts_with: String
  uri_not_starts_with: String
  uri_ends_with: String
  uri_not_ends_with: String
  AND: [PhotoScalarWhereInput!]
  OR: [PhotoScalarWhereInput!]
  NOT: [PhotoScalarWhereInput!]
}

type PhotoSubscriptionPayload {
  mutation: MutationType!
  node: Photo
  updatedFields: [String!]
  previousValues: PhotoPreviousValues
}

input PhotoSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PhotoWhereInput
  AND: [PhotoSubscriptionWhereInput!]
}

input PhotoUpdateDataInput {
  uri: String
}

input PhotoUpdateInput {
  uri: String
}

input PhotoUpdateManyDataInput {
  uri: String
}

input PhotoUpdateManyInput {
  create: [PhotoCreateInput!]
  update: [PhotoUpdateWithWhereUniqueNestedInput!]
  upsert: [PhotoUpsertWithWhereUniqueNestedInput!]
  delete: [PhotoWhereUniqueInput!]
  connect: [PhotoWhereUniqueInput!]
  set: [PhotoWhereUniqueInput!]
  disconnect: [PhotoWhereUniqueInput!]
  deleteMany: [PhotoScalarWhereInput!]
  updateMany: [PhotoUpdateManyWithWhereNestedInput!]
}

input PhotoUpdateManyMutationInput {
  uri: String
}

input PhotoUpdateManyWithWhereNestedInput {
  where: PhotoScalarWhereInput!
  data: PhotoUpdateManyDataInput!
}

input PhotoUpdateOneInput {
  create: PhotoCreateInput
  update: PhotoUpdateDataInput
  upsert: PhotoUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: PhotoWhereUniqueInput
}

input PhotoUpdateWithWhereUniqueNestedInput {
  where: PhotoWhereUniqueInput!
  data: PhotoUpdateDataInput!
}

input PhotoUpsertNestedInput {
  update: PhotoUpdateDataInput!
  create: PhotoCreateInput!
}

input PhotoUpsertWithWhereUniqueNestedInput {
  where: PhotoWhereUniqueInput!
  update: PhotoUpdateDataInput!
  create: PhotoCreateInput!
}

input PhotoWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  uri: String
  uri_not: String
  uri_in: [String!]
  uri_not_in: [String!]
  uri_lt: String
  uri_lte: String
  uri_gt: String
  uri_gte: String
  uri_contains: String
  uri_not_contains: String
  uri_starts_with: String
  uri_not_starts_with: String
  uri_ends_with: String
  uri_not_ends_with: String
  AND: [PhotoWhereInput!]
}

input PhotoWhereUniqueInput {
  id: ID
  uri: String
}

type Place {
  id: ID!
  name: String!
  category: Category!
  address: Address
  user: User
  social: Social
  headline: String
  description: String
  hours: [Hour!]
  tags(where: TagWhereInput, orderBy: TagOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Tag!]
  photos(where: PhotoWhereInput, orderBy: PhotoOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Photo!]
}

type PlaceConnection {
  pageInfo: PageInfo!
  edges: [PlaceEdge]!
  aggregate: AggregatePlace!
}

input PlaceCreateInput {
  id: ID
  name: String!
  category: Category!
  address: AddressCreateOneInput
  user: UserCreateOneInput
  social: SocialCreateOneInput
  headline: String
  description: String
  hours: HourCreateManyInput
  tags: TagCreateManyInput
  photos: PhotoCreateManyInput
}

type PlaceEdge {
  node: Place!
  cursor: String!
}

enum PlaceOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  category_ASC
  category_DESC
  headline_ASC
  headline_DESC
  description_ASC
  description_DESC
}

type PlacePreviousValues {
  id: ID!
  name: String!
  category: Category!
  headline: String
  description: String
}

type PlaceSubscriptionPayload {
  mutation: MutationType!
  node: Place
  updatedFields: [String!]
  previousValues: PlacePreviousValues
}

input PlaceSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PlaceWhereInput
  AND: [PlaceSubscriptionWhereInput!]
}

input PlaceUpdateInput {
  name: String
  category: Category
  address: AddressUpdateOneInput
  user: UserUpdateOneInput
  social: SocialUpdateOneInput
  headline: String
  description: String
  hours: HourUpdateManyInput
  tags: TagUpdateManyInput
  photos: PhotoUpdateManyInput
}

input PlaceUpdateManyMutationInput {
  name: String
  category: Category
  headline: String
  description: String
}

input PlaceWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  category: Category
  category_not: Category
  category_in: [Category!]
  category_not_in: [Category!]
  address: AddressWhereInput
  user: UserWhereInput
  social: SocialWhereInput
  headline: String
  headline_not: String
  headline_in: [String!]
  headline_not_in: [String!]
  headline_lt: String
  headline_lte: String
  headline_gt: String
  headline_gte: String
  headline_contains: String
  headline_not_contains: String
  headline_starts_with: String
  headline_not_starts_with: String
  headline_ends_with: String
  headline_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  hours_some: HourWhereInput
  hours_every: HourRestrictedWhereInput
  hours_none: HourRestrictedWhereInput
  tags_some: TagWhereInput
  photos_some: PhotoWhereInput
  AND: [PlaceWhereInput!]
}

input PlaceWhereUniqueInput {
  id: ID
  name: String
}

type Point {
  type: String
  coordinates: [Float!]!
}

input PointCreatecoordinatesInput {
  set: [Float!]
}

input PointCreateInput {
  type: String
  coordinates: PointCreatecoordinatesInput
}

input PointCreateOneInput {
  create: PointCreateInput
}

input PointUpdatecoordinatesInput {
  set: [Float!]
}

input PointUpdateDataInput {
  type: String
  coordinates: PointUpdatecoordinatesInput
}

input PointUpdateOneInput {
  create: PointCreateInput
  update: PointUpdateDataInput
  upsert: PointUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
}

input PointUpsertNestedInput {
  update: PointUpdateDataInput!
  create: PointCreateInput!
}

input PointWhereInput {
  type: String
  type_not: String
  type_in: [String!]
  type_not_in: [String!]
  type_lt: String
  type_lte: String
  type_gt: String
  type_gte: String
  type_contains: String
  type_not_contains: String
  type_starts_with: String
  type_not_starts_with: String
  type_ends_with: String
  type_not_ends_with: String
  AND: [PointWhereInput!]
}

type Query {
  article(where: ArticleWhereUniqueInput!): Article
  articles(where: ArticleWhereInput, orderBy: ArticleOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Article]!
  articlesConnection(where: ArticleWhereInput, orderBy: ArticleOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ArticleConnection!
  challenge(where: ChallengeWhereUniqueInput!): Challenge
  challenges(where: ChallengeWhereInput, orderBy: ChallengeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Challenge]!
  challengesConnection(where: ChallengeWhereInput, orderBy: ChallengeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ChallengeConnection!
  company(where: CompanyWhereUniqueInput!): Company
  companies(where: CompanyWhereInput, orderBy: CompanyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Company]!
  companiesConnection(where: CompanyWhereInput, orderBy: CompanyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CompanyConnection!
  photo(where: PhotoWhereUniqueInput!): Photo
  photos(where: PhotoWhereInput, orderBy: PhotoOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Photo]!
  photosConnection(where: PhotoWhereInput, orderBy: PhotoOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PhotoConnection!
  place(where: PlaceWhereUniqueInput!): Place
  places(where: PlaceWhereInput, orderBy: PlaceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Place]!
  placesConnection(where: PlaceWhereInput, orderBy: PlaceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PlaceConnection!
  tag(where: TagWhereUniqueInput!): Tag
  tags(where: TagWhereInput, orderBy: TagOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Tag]!
  tagsConnection(where: TagWhereInput, orderBy: TagOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TagConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  validatedQuiz(where: ValidatedQuizWhereUniqueInput!): ValidatedQuiz
  validatedQuizzes(where: ValidatedQuizWhereInput, orderBy: ValidatedQuizOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ValidatedQuiz]!
  validatedQuizzesConnection(where: ValidatedQuizWhereInput, orderBy: ValidatedQuizOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ValidatedQuizConnection!
  node(id: ID!): Node
}

type Quiz {
  question: String!
  choices: [String!]!
  answer: String!
  value: Int!
}

input QuizCreatechoicesInput {
  set: [String!]
}

input QuizCreateInput {
  question: String!
  choices: QuizCreatechoicesInput
  answer: String!
  value: Int!
}

input QuizCreateOneInput {
  create: QuizCreateInput
}

input QuizUpdatechoicesInput {
  set: [String!]
}

input QuizUpdateDataInput {
  question: String
  choices: QuizUpdatechoicesInput
  answer: String
  value: Int
}

input QuizUpdateOneInput {
  create: QuizCreateInput
  update: QuizUpdateDataInput
  upsert: QuizUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
}

input QuizUpsertNestedInput {
  update: QuizUpdateDataInput!
  create: QuizCreateInput!
}

input QuizWhereInput {
  question: String
  question_not: String
  question_in: [String!]
  question_not_in: [String!]
  question_lt: String
  question_lte: String
  question_gt: String
  question_gte: String
  question_contains: String
  question_not_contains: String
  question_starts_with: String
  question_not_starts_with: String
  question_ends_with: String
  question_not_ends_with: String
  answer: String
  answer_not: String
  answer_in: [String!]
  answer_not_in: [String!]
  answer_lt: String
  answer_lte: String
  answer_gt: String
  answer_gte: String
  answer_contains: String
  answer_not_contains: String
  answer_starts_with: String
  answer_not_starts_with: String
  answer_ends_with: String
  answer_not_ends_with: String
  value: Int
  value_not: Int
  value_in: [Int!]
  value_not_in: [Int!]
  value_lt: Int
  value_lte: Int
  value_gt: Int
  value_gte: Int
  AND: [QuizWhereInput!]
}

enum Role {
  SUPER_ADMIN
  ADMIN
  MODERATOR
  USER
  PLACE
}

type Social {
  website: String
  facebook: String
  instagram: String
}

input SocialCreateInput {
  website: String
  facebook: String
  instagram: String
}

input SocialCreateOneInput {
  create: SocialCreateInput
}

input SocialUpdateDataInput {
  website: String
  facebook: String
  instagram: String
}

input SocialUpdateOneInput {
  create: SocialCreateInput
  update: SocialUpdateDataInput
  upsert: SocialUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
}

input SocialUpsertNestedInput {
  update: SocialUpdateDataInput!
  create: SocialCreateInput!
}

input SocialWhereInput {
  website: String
  website_not: String
  website_in: [String!]
  website_not_in: [String!]
  website_lt: String
  website_lte: String
  website_gt: String
  website_gte: String
  website_contains: String
  website_not_contains: String
  website_starts_with: String
  website_not_starts_with: String
  website_ends_with: String
  website_not_ends_with: String
  facebook: String
  facebook_not: String
  facebook_in: [String!]
  facebook_not_in: [String!]
  facebook_lt: String
  facebook_lte: String
  facebook_gt: String
  facebook_gte: String
  facebook_contains: String
  facebook_not_contains: String
  facebook_starts_with: String
  facebook_not_starts_with: String
  facebook_ends_with: String
  facebook_not_ends_with: String
  instagram: String
  instagram_not: String
  instagram_in: [String!]
  instagram_not_in: [String!]
  instagram_lt: String
  instagram_lte: String
  instagram_gt: String
  instagram_gte: String
  instagram_contains: String
  instagram_not_contains: String
  instagram_starts_with: String
  instagram_not_starts_with: String
  instagram_ends_with: String
  instagram_not_ends_with: String
  AND: [SocialWhereInput!]
}

type Subscription {
  article(where: ArticleSubscriptionWhereInput): ArticleSubscriptionPayload
  challenge(where: ChallengeSubscriptionWhereInput): ChallengeSubscriptionPayload
  company(where: CompanySubscriptionWhereInput): CompanySubscriptionPayload
  photo(where: PhotoSubscriptionWhereInput): PhotoSubscriptionPayload
  place(where: PlaceSubscriptionWhereInput): PlaceSubscriptionPayload
  tag(where: TagSubscriptionWhereInput): TagSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
  validatedQuiz(where: ValidatedQuizSubscriptionWhereInput): ValidatedQuizSubscriptionPayload
}

type Tag {
  id: ID!
  label: String!
  children(where: TagWhereInput, orderBy: TagOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Tag!]
  root: Boolean
  leaf: Boolean
  category: Category!
}

type TagConnection {
  pageInfo: PageInfo!
  edges: [TagEdge]!
  aggregate: AggregateTag!
}

input TagCreateInput {
  id: ID
  label: String!
  children: TagCreateManyInput
  root: Boolean
  leaf: Boolean
  category: Category!
}

input TagCreateManyInput {
  create: [TagCreateInput!]
  connect: [TagWhereUniqueInput!]
}

type TagEdge {
  node: Tag!
  cursor: String!
}

enum TagOrderByInput {
  id_ASC
  id_DESC
  label_ASC
  label_DESC
  root_ASC
  root_DESC
  leaf_ASC
  leaf_DESC
  category_ASC
  category_DESC
}

type TagPreviousValues {
  id: ID!
  label: String!
  root: Boolean
  leaf: Boolean
  category: Category!
}

input TagScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  label: String
  label_not: String
  label_in: [String!]
  label_not_in: [String!]
  label_lt: String
  label_lte: String
  label_gt: String
  label_gte: String
  label_contains: String
  label_not_contains: String
  label_starts_with: String
  label_not_starts_with: String
  label_ends_with: String
  label_not_ends_with: String
  root: Boolean
  root_not: Boolean
  leaf: Boolean
  leaf_not: Boolean
  category: Category
  category_not: Category
  category_in: [Category!]
  category_not_in: [Category!]
  AND: [TagScalarWhereInput!]
  OR: [TagScalarWhereInput!]
  NOT: [TagScalarWhereInput!]
}

type TagSubscriptionPayload {
  mutation: MutationType!
  node: Tag
  updatedFields: [String!]
  previousValues: TagPreviousValues
}

input TagSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: TagWhereInput
  AND: [TagSubscriptionWhereInput!]
}

input TagUpdateDataInput {
  label: String
  children: TagUpdateManyInput
  root: Boolean
  leaf: Boolean
  category: Category
}

input TagUpdateInput {
  label: String
  children: TagUpdateManyInput
  root: Boolean
  leaf: Boolean
  category: Category
}

input TagUpdateManyDataInput {
  label: String
  root: Boolean
  leaf: Boolean
  category: Category
}

input TagUpdateManyInput {
  create: [TagCreateInput!]
  update: [TagUpdateWithWhereUniqueNestedInput!]
  upsert: [TagUpsertWithWhereUniqueNestedInput!]
  delete: [TagWhereUniqueInput!]
  connect: [TagWhereUniqueInput!]
  set: [TagWhereUniqueInput!]
  disconnect: [TagWhereUniqueInput!]
  deleteMany: [TagScalarWhereInput!]
  updateMany: [TagUpdateManyWithWhereNestedInput!]
}

input TagUpdateManyMutationInput {
  label: String
  root: Boolean
  leaf: Boolean
  category: Category
}

input TagUpdateManyWithWhereNestedInput {
  where: TagScalarWhereInput!
  data: TagUpdateManyDataInput!
}

input TagUpdateWithWhereUniqueNestedInput {
  where: TagWhereUniqueInput!
  data: TagUpdateDataInput!
}

input TagUpsertWithWhereUniqueNestedInput {
  where: TagWhereUniqueInput!
  update: TagUpdateDataInput!
  create: TagCreateInput!
}

input TagWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  label: String
  label_not: String
  label_in: [String!]
  label_not_in: [String!]
  label_lt: String
  label_lte: String
  label_gt: String
  label_gte: String
  label_contains: String
  label_not_contains: String
  label_starts_with: String
  label_not_starts_with: String
  label_ends_with: String
  label_not_ends_with: String
  children_some: TagWhereInput
  root: Boolean
  root_not: Boolean
  leaf: Boolean
  leaf_not: Boolean
  category: Category
  category_not: Category
  category_in: [Category!]
  category_not_in: [Category!]
  AND: [TagWhereInput!]
}

input TagWhereUniqueInput {
  id: ID
}

enum Theme {
  ALIMENTATION
  CONSUMPTION
  WATER
  ENERGY
}

type User {
  id: ID!
  firstName: String
  lastName: String
  email: String
  phone: String
  password: String
  role: Role
  isRepresentative: Boolean
  company: Company
  points: Int
  validatedChallenges(where: ChallengeWhereInput, orderBy: ChallengeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Challenge!]
  validatedQuizzes(where: ValidatedQuizWhereInput, orderBy: ValidatedQuizOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ValidatedQuiz!]
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  id: ID
  firstName: String
  lastName: String
  email: String
  phone: String
  password: String
  role: Role
  isRepresentative: Boolean
  company: CompanyCreateOneWithoutUsersInput
  points: Int
  validatedChallenges: ChallengeCreateManyInput
  validatedQuizzes: ValidatedQuizCreateManyInput
}

input UserCreateManyWithoutCompanyInput {
  create: [UserCreateWithoutCompanyInput!]
  connect: [UserWhereUniqueInput!]
}

input UserCreateOneInput {
  create: UserCreateInput
  connect: UserWhereUniqueInput
}

input UserCreateWithoutCompanyInput {
  id: ID
  firstName: String
  lastName: String
  email: String
  phone: String
  password: String
  role: Role
  isRepresentative: Boolean
  points: Int
  validatedChallenges: ChallengeCreateManyInput
  validatedQuizzes: ValidatedQuizCreateManyInput
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  firstName_ASC
  firstName_DESC
  lastName_ASC
  lastName_DESC
  email_ASC
  email_DESC
  phone_ASC
  phone_DESC
  password_ASC
  password_DESC
  role_ASC
  role_DESC
  isRepresentative_ASC
  isRepresentative_DESC
  points_ASC
  points_DESC
}

type UserPreviousValues {
  id: ID!
  firstName: String
  lastName: String
  email: String
  phone: String
  password: String
  role: Role
  isRepresentative: Boolean
  points: Int
}

input UserScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  firstName: String
  firstName_not: String
  firstName_in: [String!]
  firstName_not_in: [String!]
  firstName_lt: String
  firstName_lte: String
  firstName_gt: String
  firstName_gte: String
  firstName_contains: String
  firstName_not_contains: String
  firstName_starts_with: String
  firstName_not_starts_with: String
  firstName_ends_with: String
  firstName_not_ends_with: String
  lastName: String
  lastName_not: String
  lastName_in: [String!]
  lastName_not_in: [String!]
  lastName_lt: String
  lastName_lte: String
  lastName_gt: String
  lastName_gte: String
  lastName_contains: String
  lastName_not_contains: String
  lastName_starts_with: String
  lastName_not_starts_with: String
  lastName_ends_with: String
  lastName_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  phone: String
  phone_not: String
  phone_in: [String!]
  phone_not_in: [String!]
  phone_lt: String
  phone_lte: String
  phone_gt: String
  phone_gte: String
  phone_contains: String
  phone_not_contains: String
  phone_starts_with: String
  phone_not_starts_with: String
  phone_ends_with: String
  phone_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  role: Role
  role_not: Role
  role_in: [Role!]
  role_not_in: [Role!]
  isRepresentative: Boolean
  isRepresentative_not: Boolean
  points: Int
  points_not: Int
  points_in: [Int!]
  points_not_in: [Int!]
  points_lt: Int
  points_lte: Int
  points_gt: Int
  points_gte: Int
  AND: [UserScalarWhereInput!]
  OR: [UserScalarWhereInput!]
  NOT: [UserScalarWhereInput!]
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
}

input UserUpdateDataInput {
  firstName: String
  lastName: String
  email: String
  phone: String
  password: String
  role: Role
  isRepresentative: Boolean
  company: CompanyUpdateOneWithoutUsersInput
  points: Int
  validatedChallenges: ChallengeUpdateManyInput
  validatedQuizzes: ValidatedQuizUpdateManyInput
}

input UserUpdateInput {
  firstName: String
  lastName: String
  email: String
  phone: String
  password: String
  role: Role
  isRepresentative: Boolean
  company: CompanyUpdateOneWithoutUsersInput
  points: Int
  validatedChallenges: ChallengeUpdateManyInput
  validatedQuizzes: ValidatedQuizUpdateManyInput
}

input UserUpdateManyDataInput {
  firstName: String
  lastName: String
  email: String
  phone: String
  password: String
  role: Role
  isRepresentative: Boolean
  points: Int
}

input UserUpdateManyMutationInput {
  firstName: String
  lastName: String
  email: String
  phone: String
  password: String
  role: Role
  isRepresentative: Boolean
  points: Int
}

input UserUpdateManyWithoutCompanyInput {
  create: [UserCreateWithoutCompanyInput!]
  delete: [UserWhereUniqueInput!]
  connect: [UserWhereUniqueInput!]
  set: [UserWhereUniqueInput!]
  disconnect: [UserWhereUniqueInput!]
  update: [UserUpdateWithWhereUniqueWithoutCompanyInput!]
  upsert: [UserUpsertWithWhereUniqueWithoutCompanyInput!]
  deleteMany: [UserScalarWhereInput!]
  updateMany: [UserUpdateManyWithWhereNestedInput!]
}

input UserUpdateManyWithWhereNestedInput {
  where: UserScalarWhereInput!
  data: UserUpdateManyDataInput!
}

input UserUpdateOneInput {
  create: UserCreateInput
  update: UserUpdateDataInput
  upsert: UserUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: UserWhereUniqueInput
}

input UserUpdateWithoutCompanyDataInput {
  firstName: String
  lastName: String
  email: String
  phone: String
  password: String
  role: Role
  isRepresentative: Boolean
  points: Int
  validatedChallenges: ChallengeUpdateManyInput
  validatedQuizzes: ValidatedQuizUpdateManyInput
}

input UserUpdateWithWhereUniqueWithoutCompanyInput {
  where: UserWhereUniqueInput!
  data: UserUpdateWithoutCompanyDataInput!
}

input UserUpsertNestedInput {
  update: UserUpdateDataInput!
  create: UserCreateInput!
}

input UserUpsertWithWhereUniqueWithoutCompanyInput {
  where: UserWhereUniqueInput!
  update: UserUpdateWithoutCompanyDataInput!
  create: UserCreateWithoutCompanyInput!
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  firstName: String
  firstName_not: String
  firstName_in: [String!]
  firstName_not_in: [String!]
  firstName_lt: String
  firstName_lte: String
  firstName_gt: String
  firstName_gte: String
  firstName_contains: String
  firstName_not_contains: String
  firstName_starts_with: String
  firstName_not_starts_with: String
  firstName_ends_with: String
  firstName_not_ends_with: String
  lastName: String
  lastName_not: String
  lastName_in: [String!]
  lastName_not_in: [String!]
  lastName_lt: String
  lastName_lte: String
  lastName_gt: String
  lastName_gte: String
  lastName_contains: String
  lastName_not_contains: String
  lastName_starts_with: String
  lastName_not_starts_with: String
  lastName_ends_with: String
  lastName_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  phone: String
  phone_not: String
  phone_in: [String!]
  phone_not_in: [String!]
  phone_lt: String
  phone_lte: String
  phone_gt: String
  phone_gte: String
  phone_contains: String
  phone_not_contains: String
  phone_starts_with: String
  phone_not_starts_with: String
  phone_ends_with: String
  phone_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  role: Role
  role_not: Role
  role_in: [Role!]
  role_not_in: [Role!]
  isRepresentative: Boolean
  isRepresentative_not: Boolean
  company: CompanyWhereInput
  points: Int
  points_not: Int
  points_in: [Int!]
  points_not_in: [Int!]
  points_lt: Int
  points_lte: Int
  points_gt: Int
  points_gte: Int
  validatedChallenges_some: ChallengeWhereInput
  validatedQuizzes_some: ValidatedQuizWhereInput
  AND: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
  email: String
}

type ValidatedQuiz {
  id: ID!
  article: Article!
  status: Boolean!
}

type ValidatedQuizConnection {
  pageInfo: PageInfo!
  edges: [ValidatedQuizEdge]!
  aggregate: AggregateValidatedQuiz!
}

input ValidatedQuizCreateInput {
  id: ID
  article: ArticleCreateOneInput!
  status: Boolean!
}

input ValidatedQuizCreateManyInput {
  create: [ValidatedQuizCreateInput!]
  connect: [ValidatedQuizWhereUniqueInput!]
}

type ValidatedQuizEdge {
  node: ValidatedQuiz!
  cursor: String!
}

enum ValidatedQuizOrderByInput {
  id_ASC
  id_DESC
  status_ASC
  status_DESC
}

type ValidatedQuizPreviousValues {
  id: ID!
  status: Boolean!
}

input ValidatedQuizScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  status: Boolean
  status_not: Boolean
  AND: [ValidatedQuizScalarWhereInput!]
  OR: [ValidatedQuizScalarWhereInput!]
  NOT: [ValidatedQuizScalarWhereInput!]
}

type ValidatedQuizSubscriptionPayload {
  mutation: MutationType!
  node: ValidatedQuiz
  updatedFields: [String!]
  previousValues: ValidatedQuizPreviousValues
}

input ValidatedQuizSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ValidatedQuizWhereInput
  AND: [ValidatedQuizSubscriptionWhereInput!]
}

input ValidatedQuizUpdateDataInput {
  article: ArticleUpdateOneRequiredInput
  status: Boolean
}

input ValidatedQuizUpdateInput {
  article: ArticleUpdateOneRequiredInput
  status: Boolean
}

input ValidatedQuizUpdateManyDataInput {
  status: Boolean
}

input ValidatedQuizUpdateManyInput {
  create: [ValidatedQuizCreateInput!]
  update: [ValidatedQuizUpdateWithWhereUniqueNestedInput!]
  upsert: [ValidatedQuizUpsertWithWhereUniqueNestedInput!]
  delete: [ValidatedQuizWhereUniqueInput!]
  connect: [ValidatedQuizWhereUniqueInput!]
  set: [ValidatedQuizWhereUniqueInput!]
  disconnect: [ValidatedQuizWhereUniqueInput!]
  deleteMany: [ValidatedQuizScalarWhereInput!]
  updateMany: [ValidatedQuizUpdateManyWithWhereNestedInput!]
}

input ValidatedQuizUpdateManyMutationInput {
  status: Boolean
}

input ValidatedQuizUpdateManyWithWhereNestedInput {
  where: ValidatedQuizScalarWhereInput!
  data: ValidatedQuizUpdateManyDataInput!
}

input ValidatedQuizUpdateWithWhereUniqueNestedInput {
  where: ValidatedQuizWhereUniqueInput!
  data: ValidatedQuizUpdateDataInput!
}

input ValidatedQuizUpsertWithWhereUniqueNestedInput {
  where: ValidatedQuizWhereUniqueInput!
  update: ValidatedQuizUpdateDataInput!
  create: ValidatedQuizCreateInput!
}

input ValidatedQuizWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  article: ArticleWhereInput
  status: Boolean
  status_not: Boolean
  AND: [ValidatedQuizWhereInput!]
}

input ValidatedQuizWhereUniqueInput {
  id: ID
}
`
      }
    